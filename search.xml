<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vue 2.0 高级实战-开发移动端音乐WebApp 课程笔记（第六章 歌手详情页开发）]]></title>
    <url>%2F2017%2F07%2F31%2FVue-2-0-%E9%AB%98%E7%BA%A7%E5%AE%9E%E6%88%98-%E5%BC%80%E5%8F%91%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%9F%B3%E4%B9%90WebApp-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%EF%BC%88%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%AD%8C%E6%89%8B%E8%AF%A6%E6%83%85%E9%A1%B5%E5%BC%80%E5%8F%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Vue 2.0 高级实战-开发移动端音乐WebApp 课程笔记（第六章 歌手详情页开发）子路由配置以及转场动画实现 添加组件singer-detail 12345678910111213141516171819202122232425&lt;template&gt; &lt;transition name="slide"&gt; &lt;div class="singer-detail"&gt;&lt;/div&gt; &lt;/transition&gt; &lt;/template&gt;&lt;script&gt;&lt;/script&gt;&lt;style scoped lang="stylus" rel="stylesheet/stylus"&gt; @import "~common/stylus/variable" .singer-detail position: fixed z-index: 100 top: 0 left: 0 right: 0 bottom: 0 background: $color-background .slide-enter-active, .slide-leave-active transition: all 0.3s .slide-enter, .slide-leave-to transform: translate3d(100%, 0, 0)&lt;/style&gt; 路由配置 12345678910&#123; path: '/singer', component: Singer, children: [ &#123; path: ':id', component: SingerDetail &#125; ]&#125; singer.vue添加&lt;view-router&gt; listview.vue添加点击事件 123selectItem(item) &#123; this.$emit('select', item)&#125; 基础组件不会有业务逻辑, 仅仅派发事件 singer.vue添加事件12345selectSinger(singer) &#123; this.$router.push(&#123; path: `/singer/$&#123;singer.id&#125;` &#125;)&#125;, 初识 Vuex学习一个技术栈时, 首先通过3w方式 vuex是什么Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式 vuex解决什么问题多个组件的数据共享路由间的复杂数据传递 怎么使用vuex Vuex 初始化及歌手数据的配置创建目录 store index.js 入口 state.js 所有状态 mutations.js mutations-type.js mutations相关字符串常量 actions.js 异步操作, mutations封装 getter.js 获取state映射 为什么要有mutations-type 书写方便 方便lint工具检测 index.js 1234567891011121314151617181920import Vue from 'vue'import Vuex from 'vuex'import * as actions from './actions'import * as getters from './getters'import state from './state'import mutations from './mutations'import createLogger from 'vuex/dist/logger'Vue.use(Vuex)const debug = process.env.NODE_ENV !== 'production'export default new Vuex.Store(&#123; actions, getters, state, mutations, strict: debug, plugins: debug ? [createLogger()] : []&#125;) state.js 12345const state = &#123; singer: &#123;&#125;&#125;export default state mutation-types.js 1export const SET_SINGER = 'SET_SINGER' mutations 123456789import * as types from './mutation-types'const matutaions = &#123; [types.SET_SINGER](state, singer) &#123; state.singer = singer &#125;&#125;export default matutaions getters.js 1export const singer = state =&gt; state.singer singer.vue 设置数据 1234567import &#123;mapMutations&#125; from 'vuex'methods: &#123; ...mapMutations(&#123; setSinger: 'SET_SINGER' &#125;)&#125; singer.vue 设置数据 1234567import &#123;mapMutations&#125; from 'vuex'methods: &#123; ...mapMutations(&#123; setSinger: 'SET_SINGER' &#125;)&#125; 歌手详情数据抓取 api/singer.js 添加方法12345678910111213141516export function getSingerDetail(singerId) &#123; const url = 'https://c.y.qq.com/v8/fcg-bin/fcg_v8_singer_track_cp.fcg' const data = Object.assign(&#123;&#125;, commonParams, &#123; hostUin: 0, needNewCode: 0, platform: 'yqq', order: 'listen', begin: 0, num: 80, songstatus: 1, singermid: singerId &#125;) return jsonp(url, data, options)&#125; 歌手详情数据处理和Song类的封装创建class Song123456789101112export default class Song &#123; constructor(&#123;id, mid, singer, name, album, duration, image, url&#125;) &#123; this.id = id this.mid = mid this.singer = singer this.name = name this.album = album this.duration = duration this.image = image this.url = url &#125;&#125; 设计成类的好处 集中一处维护 面向对象的方式, 扩展性强 添加工厂方法createSong1234567891011121314151617181920212223export function createSong(musicData) &#123; return new Song(&#123; id: musicData.songid, mid: musicData.songmid, singer: filterSinger(musicData.singer), name: musicData.songname, album: musicData.albumname, duration: musicData.interval, image: `https://y.gtimg.cn/music/photo_new/T002R300x300M000$&#123;musicData.albummid&#125;.jpg?max_age=2592000`, url: `http://ws.stream.qqmusic.qq.com/$&#123;musicData.songid&#125;.m4a?fromtag=46` &#125;)&#125;export function filterSinger(singer) &#123; let ret = [] if (!singer) &#123; return '' &#125; singer.forEach((s) =&gt; &#123; ret.push(s.name) &#125;) return ret.join('/')&#125; music-list 组件开发 添加业务组件music-list.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131&lt;template&gt; &lt;div class="music-list"&gt; &lt;div class="back"&gt; &lt;i class="icon-back"&gt;&lt;/i&gt; &lt;/div&gt; &lt;h1 class="title" v-html="title"&gt;&lt;/h1&gt; &lt;div class="bg-image" :style="bgStyle" ref="bgImage"&gt; &lt;div class="play-wrapper"&gt; &lt;div ref="playBtn" v-show="songs.length&gt;0" class="play"&gt; &lt;i class="icon-play"&gt;&lt;/i&gt; &lt;span class="text"&gt;随机播放全部&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="filter" ref="filter"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: &#123; bgImage: &#123; type: String, default: '' &#125;, songs: &#123; type: Array, default: [] &#125;, title: &#123; type: String, default: '' &#125; &#125;, computed: &#123; bgStyle() &#123; return `background-image:url($&#123;this.bgImage&#125;)` &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped lang="stylus" rel="stylesheet/stylus"&gt; @import "~common/stylus/variable" @import "~common/stylus/mixin" .music-list position: fixed z-index: 100 top: 0 left: 0 bottom: 0 right: 0 background: $color-background .back position absolute top: 0 left: 6px z-index: 50 .icon-back display: block padding: 10px font-size: $font-size-large-x color: $color-theme .title position: absolute top: 0 left: 10% z-index: 40 width: 80% no-wrap() text-align: center line-height: 40px font-size: $font-size-large color: $color-text .bg-image position: relative width: 100% height: 0 padding-top: 70% transform-origin: top background-size: cover .play-wrapper position: absolute bottom: 20px z-index: 50 width: 100% .play box-sizing: border-box width: 135px padding: 7px 0 margin: 0 auto text-align: center border: 1px solid $color-theme color: $color-theme border-radius: 100px font-size: 0 .icon-play display: inline-block vertical-align: middle margin-right: 6px font-size: $font-size-medium-x .text display: inline-block vertical-align: middle font-size: $font-size-small .filter position: absolute top: 0 left: 0 width: 100% height: 100% background: rgba(7, 17, 27, 0.4) .bg-layer position: relative height: 100% background: $color-background .list position: fixed top: 0 bottom: 0 width: 100% background: $color-background .song-list-wrapper padding: 20px 30px .loading-container position: absolute width: 100% top: 50% transform: translateY(-50%)&lt;/style&gt; 添加基础组件song-list.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;template&gt; &lt;div class="song-list"&gt; &lt;ul&gt; &lt;li class="item" v-for="song in songs"&gt; &lt;div class="content"&gt; &lt;h2 class="name"&gt;&#123;&#123;song.name&#125;&#125;&lt;/h2&gt; &lt;p class="desc"&gt;&#123;&#123;getDesc(song)&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: &#123; songs: &#123; type: Array, default: [] &#125; &#125;, methods: &#123; getDesc(song) &#123; return `$&#123;song.singer&#125;·$&#123;song.album&#125;` &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped lang="stylus" rel="stylesheet/stylus"&gt; @import "~common/stylus/variable" @import "~common/stylus/mixin" .song-list .item display: flex align-items: center box-sizing: border-box height: 64px font-size: $font-size-medium .content flex: 1 line-height: 20px overflow: hidden .name no-wrap() color: $color-text .desc no-wrap() margin-top: 4px color: $color-text-d&lt;/style&gt; dom.js 添加 prefixStyle 123456789101112131415161718192021222324252627282930313233// js中的css前缀补全let elementStyle = document.createElement('div').style// 浏览器能力检测let vendor = (() =&gt; &#123; let transformNames = &#123; webkit: 'webkitTransform', Moz: 'MozTransform', O: 'OTransform', ms: 'msTransform', standard: 'transform' &#125; for (let key in transformNames) &#123; if (elementStyle[transformNames[key]] !== undefined) &#123; return key &#125; &#125; return false&#125;)()export function prefixStyle(style) &#123; if (vendor === false) &#123; return false &#125; if (vendor === 'standard') &#123; return style &#125; return vendor + style.charAt(0).toUpperCase() + style.substr(1)&#125; 完善music-list.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210&lt;template&gt; &lt;div class="music-list"&gt; &lt;div class="back" @click="back"&gt; &lt;i class="icon-back"&gt;&lt;/i&gt; &lt;/div&gt; &lt;h1 class="title" v-html="title"&gt;&lt;/h1&gt; &lt;div class="bg-image" :style="bgStyle" ref="bgImage"&gt; &lt;div class="play-wrapper"&gt; &lt;div ref="playBtn" v-show="songs.length&gt;0" class="play"&gt; &lt;i class="icon-play"&gt;&lt;/i&gt; &lt;span class="text"&gt;随机播放全部&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="filter" ref="filter"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="bg-layer" ref="layer"&gt;&lt;/div&gt; &lt;scroll :data="songs" @scroll="scroll" :listen-scroll="listenScroll" :probe-type="probeType" class="list" ref="list"&gt; &lt;div class="song-list-wrapper"&gt; &lt;song-list :songs="songs"&gt;&lt;/song-list&gt; &lt;/div&gt; &lt;div v-show="!songs.length" class="loading-container"&gt; &lt;loading&gt;&lt;/loading&gt; &lt;/div&gt; &lt;/scroll&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Scroll from 'base/scroll/scroll' import Loading from 'base/loading/loading' import SongList from 'base/song-list/song-list' import &#123;prefixStyle&#125; from 'common/js/dom' const RESERVED_HEIGHT = 40 const transform = prefixStyle('transform') const backdrop = prefixStyle('backdrop-filter') export default &#123; props: &#123; bgImage: &#123; type: String, default: '' &#125;, songs: &#123; type: Array, default: [] &#125;, title: &#123; type: String, default: '' &#125; &#125;, data() &#123; return &#123; scrollY: 0 &#125; &#125;, computed: &#123; bgStyle() &#123; return `background-image:url($&#123;this.bgImage&#125;)` &#125; &#125;, created() &#123; this.probeType = 3 this.listenScroll = true &#125;, mounted() &#123; this.imageHeight = this.$refs.bgImage.clientHeight this.minTransalteY = -this.imageHeight + RESERVED_HEIGHT this.$refs.list.$el.style.top = `$&#123;this.imageHeight&#125;px` &#125;, methods: &#123; scroll(pos) &#123; this.scrollY = pos.y &#125;, back() &#123; this.$router.back() &#125; &#125;, watch: &#123; scrollY(newVal) &#123; let translateY = Math.max(this.minTransalteY, newVal) let scale = 1 let zIndex = 0 let blur = 0 // 计算图片放大比例 const percent = Math.abs(newVal / this.imageHeight) if (newVal &gt; 0) &#123; scale = 1 + percent zIndex = 10 &#125; else &#123; // 计算模糊比例 blur = Math.min(20, percent * 20) &#125; this.$refs.layer.style[transform] = `translate3d(0,$&#123;translateY&#125;px,0)` this.$refs.filter.style[backdrop] = `blur($&#123;blur&#125;px)` if (newVal &lt; this.minTransalteY) &#123; // 向上滑动超过minTransalteY, 改变图片zIndex和高度, 按钮消失 zIndex = 10 this.$refs.bgImage.style.paddingTop = 0 this.$refs.bgImage.style.height = `$&#123;RESERVED_HEIGHT&#125;px` this.$refs.playBtn.style.display = 'none' &#125; else &#123; // 反之, 重置 this.$refs.bgImage.style.paddingTop = '70%' this.$refs.bgImage.style.height = 0 this.$refs.playBtn.style.display = '' &#125; this.$refs.bgImage.style[transform] = `scale($&#123;scale&#125;)` this.$refs.bgImage.style.zIndex = zIndex &#125; &#125;, components: &#123; Scroll, Loading, SongList &#125; &#125;&lt;/script&gt;&lt;style scoped lang="stylus" rel="stylesheet/stylus"&gt; @import "~common/stylus/variable" @import "~common/stylus/mixin" .music-list position: fixed z-index: 100 top: 0 left: 0 bottom: 0 right: 0 background: $color-background .back position absolute top: 0 left: 6px z-index: 50 .icon-back display: block padding: 10px font-size: $font-size-large-x color: $color-theme .title position: absolute top: 0 left: 10% z-index: 40 width: 80% no-wrap() text-align: center line-height: 40px font-size: $font-size-large color: $color-text .bg-image position: relative width: 100% height: 0 padding-top: 70% transform-origin: top background-size: cover .play-wrapper position: absolute bottom: 20px z-index: 50 width: 100% .play box-sizing: border-box width: 135px padding: 7px 0 margin: 0 auto text-align: center border: 1px solid $color-theme color: $color-theme border-radius: 100px font-size: 0 .icon-play display: inline-block vertical-align: middle margin-right: 6px font-size: $font-size-medium-x .text display: inline-block vertical-align: middle font-size: $font-size-small .filter position: absolute top: 0 left: 0 width: 100% height: 100% background: rgba(7, 17, 27, 0.4) .bg-layer position: relative height: 100% background: $color-background .list position: fixed top: 0 bottom: 0 width: 100% background: $color-background .song-list-wrapper padding: 20px 30px .loading-container position: absolute width: 100% top: 50% transform: translateY(-50%)&lt;/style&gt;]]></content>
      <categories>
        <category>技术</category>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>慕课网</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 2.0 高级实战-开发移动端音乐WebApp 课程笔记（第五章 歌手页面开发）]]></title>
    <url>%2F2017%2F07%2F30%2FVue-2-0-%E9%AB%98%E7%BA%A7%E5%AE%9E%E6%88%98-%E5%BC%80%E5%8F%91%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%9F%B3%E4%B9%90WebApp-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%EF%BC%88%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%AD%8C%E6%89%8B%E9%A1%B5%E9%9D%A2%E5%BC%80%E5%8F%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Vue 2.0 高级实战-开发移动端音乐WebApp 课程笔记（第五章 歌手页面开发）歌手数据接口抓取12345678910111213141516171819import jsonp from 'common/js/jsonp'import &#123;commonParams, options&#125; from './config'export function getSingerList() &#123; const url = 'https://c.y.qq.com/v8/fcg-bin/v8.fcg' const data = Object.assign(&#123;&#125;, commonParams, &#123; channel: 'singer', page: 'list', key: 'all_all_all', pagesize: 100, pagenum: 1, hostUin: 0, needNewCode: 0, platform: 'yqq' &#125;) return jsonp(url, data, options)&#125; 歌手数据处理和 Singer 类的封装1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950_normalizeSinger(list) &#123; let map = &#123; hot: &#123; title: HOT_NAME, items: [] &#125; &#125; // 填充hot list.forEach((item, index) =&gt; &#123; if (index &lt; HOT_SINGER_LEN) &#123; // 封装 类Singer map.hot.items.push(new Singer(&#123; name: item.Fsinger_name, id: item.Fsinger_mid &#125;)) &#125; // 聚合 const key = item.Findex // 创建对象 if (!map[key]) &#123; map[key] = &#123; title: key, items: [] &#125; &#125; map[key].items.push(new Singer(&#123; name: item.Fsinger_name, id: item.Fsinger_mid &#125;)) &#125;) // 为了得到有序列表，我们需要处理 map let ret = [] let hot = [] for (let key in map) &#123; let val = map[key] if (val.title.match(/[a-zA-Z]/)) &#123; ret.push(val) &#125; else if (val.title === HOT_NAME) &#123; hot.push(val) &#125; &#125; ret.sort((a, b) =&gt; &#123; return a.title.charCodeAt(0) - b.title.charCodeAt(0) &#125;) return hot.concat(ret)&#125; 新建common/js/singer.js1234567export default class Singer &#123; constructor(&#123;id, name&#125;) &#123; this.id = id this.name = name this.avatar = `https://y.gtimg.cn/music/photo_new/T001R300x300M000$&#123;id&#125;.jpg?max_age=2592000` &#125;&#125; listview 基础组件的开发和应用-滚动列表实现新建通用组件 listview123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;template&gt; &lt;scroll :data="data" class="listview"&gt; &lt;ul&gt; &lt;li v-for="group in data" class="list-group" ref="listGroup"&gt; &lt;h2 class="list-group-title"&gt;&#123;&#123;group.title&#125;&#125;&lt;/h2&gt; &lt;uL&gt; &lt;li v-for="item in group.items" class="list-group-item"&gt; &lt;img class="avatar" v-lazy="item.avatar"&gt; &lt;span class="name"&gt;&#123;&#123;item.name&#125;&#125;&lt;/span&gt; &lt;/li&gt; &lt;/uL&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/scroll&gt;&lt;/template&gt;&lt;script&gt; import Scroll from 'base/scroll/scroll' export default &#123; props: &#123; data: &#123; type: Array, default: [] &#125; &#125;, components: &#123; Scroll &#125; &#125;&lt;/script&gt;&lt;style scoped lang="stylus" rel="stylesheet/stylus"&gt; @import "~common/stylus/variable" .listview position: relative width: 100% height: 100% overflow: hidden background: $color-background .list-group padding-bottom: 30px .list-group-title height: 30px line-height: 30px padding-left: 20px font-size: $font-size-small color: $color-text-l background: $color-highlight-background .list-group-item display: flex align-items: center padding: 20px 0 0 30px .avatar width: 50px height: 50px border-radius: 50% .name margin-left: 20px color: $color-text-l font-size: $font-size-medium .list-shortcut position: absolute z-index: 30 right: 0 top: 50% transform: translateY(-50%) width: 20px padding: 20px 0 border-radius: 10px text-align: center background: $color-background-d font-family: Helvetica .item padding: 3px line-height: 1 color: $color-text-l font-size: $font-size-small &amp;.current color: $color-theme .list-fixed position: absolute top: 0 left: 0 width: 100% .fixed-title height: 30px line-height: 30px padding-left: 20px font-size: $font-size-small color: $color-text-l background: $color-highlight-background .loading-container position: absolute width: 100% top: 50% transform: translateY(-50%)&lt;/style&gt; listview 基础组件的开发和应用-右侧快速入口实现 dom.js 添加通用方法 12345678export function getData(el, name, val) &#123; const prefix = 'data-' name = prefix + name if (val) &#123; return el.setAttribute(name, val) &#125; return el.getAttribute(name)&#125; scroll.vue 添加方法 1234567scrollTo() &#123; this.scroll &amp;&amp; this.scroll.scrollTo.apply(this.scroll, arguments)&#125;,scrollToElement() &#123; // 用apply保证调用方法时上下文相同 this.scroll &amp;&amp; this.scroll.scrollToElement.apply(this.scroll, arguments)&#125; viewlist.vue添加dom 123456789&lt;div class="list-shortcut" @touchstart.stop.prevent="onShortcutTouchStart" @touchmove.stop.prevent="onShortcutTouchMove" @touchend.stop&gt; &lt;ul&gt; &lt;li v-for="(item, index) in shortcutList" :data-index="index" class="item"&gt;&#123;&#123;item&#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; viewlist.vue添加方法 12345678910111213141516171819onShortcutTouchStart(e) &#123; let anchorIndex = getData(e.target, 'index') let firstTouch = e.touches[0] this.touch.y1 = firstTouch.pageY this.touch.anchorIndex = anchorIndex this.$refs.listview.scrollToElement(this.$refs.listGroup[anchorIndex], 0) this._scrollTo(anchorIndex)&#125;,onShortcutTouchMove(e) &#123; let firstTouch = e.touches[0] this.touch.y2 = firstTouch.pageY let delta = (this.touch.y2 - this.touch.y1) / ANCHOR_HEIGHT | 0 let anchorIndex = parseInt(this.touch.anchorIndex) + delta this._scrollTo(anchorIndex)&#125;,_scrollTo(index) &#123; this.$refs.listview.scrollToElement(this.$refs.listGroup[index], 0)&#125; 计算所有group的高度 1234567891011_calculateHeight() &#123; this.listHeight = [] const list = this.$refs.listGroup let height = 0 this.listHeight.push(height) for (let i = 0; i &lt; list.length; i++) &#123; let item = list[i] height += item.clientHeight this.listHeight.push(height) &#125;&#125; 6 添加watch 计算 currentIndex12345678910111213141516171819202122232425262728watch: &#123; data() &#123; setTimeout(() =&gt; &#123; // 数据变化到dom的变化有一个延时 this._calculateHeight() &#125;, 20) &#125;, scrollY(newY) &#123; const listHeight = this.listHeight // 当滚动到顶部，newY&gt;0 if (newY &gt; 0) &#123; this.currentIndex = 0 return &#125; // 在中间部分滚动 for (let i = 0; i &lt; listHeight.length - 1; i++) &#123; let height1 = listHeight[i] let height2 = listHeight[i + 1] if (-newY &gt;= height1 &amp;&amp; -newY &lt; height2) &#123; this.currentIndex = i this.diff = height2 + newY return &#125; &#125; // 当滚动到底部，且-newY大于最后一个元素的上限 this.currentIndex = listHeight.length - 2 &#125;&#125; 总结:联动思路 知道实时滚动位置 根据滚动位置计算落在哪个group区间 根据区间计算索引哪个高亮 listview 基础组件的开发和应用-滚动固定标题实现 添加dom 123&lt;div class="list-fixed" ref="fixed" v-show="fixedTitle"&gt; &lt;div class="fixed-title"&gt;&#123;&#123;fixedTitle&#125;&#125; &lt;/div&gt;&lt;/div&gt; 添加计算属性 123456fixedTitle() &#123; if (this.scrollY &gt; 0) &#123; return '' &#125; return this.data[this.currentIndex] ? this.data[this.currentIndex].title : ''&#125; 添加watch 123456789diff(newVal) &#123; let fixedTop = (newVal &gt; 0 &amp;&amp; newVal &lt; TITLE_HEIGHT) ? newVal - TITLE_HEIGHT : 0 // 减少dom操作的频度 if (this.fixedTop === fixedTop) &#123; return &#125; this.fixedTop = fixedTop this.$refs.fixed.style.transform = `translate3d(0,$&#123;fixedTop&#125;px,0)`&#125;]]></content>
      <categories>
        <category>技术</category>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>慕课网</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 2.0 高级实战-开发移动端音乐WebApp 课程笔记（第四章 推荐页面开发）]]></title>
    <url>%2F2017%2F07%2F26%2FVue-2-0-%E9%AB%98%E7%BA%A7%E5%AE%9E%E6%88%98-%E5%BC%80%E5%8F%91%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%9F%B3%E4%B9%90WebApp-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%8E%A8%E8%8D%90%E9%A1%B5%E9%9D%A2%E5%BC%80%E5%8F%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Vue 2.0 高级实战-开发移动端音乐WebApp 课程笔记（第四章 推荐页面开发）jsonp原理介绍+Promise封装jsonpjsonp github库 Promise封装123456789101112131415161718192021222324import originJsonp from 'jsonp'export default function jsonp(url, data, option) &#123; url += (url.indexOf('?') &lt; 0 ? '?' : '&amp;') + param(data) return new Promise((resolve, reject) =&gt; &#123; originJsonp(url, option, (err, data) =&gt; &#123; if (!err) &#123; resolve(data) &#125; else &#123; reject(err) &#125; &#125;) &#125;)&#125;export function param(data) &#123; let url = '' for (var k in data) &#123; let value = data[k] !== undefined ? data[k] : '' url += '&amp;' + k + '=' + encodeURIComponent(value) &#125; return url ? url.substring(1) : ''&#125; jsonp的应用+轮播图数据抓取 添加请求通用配置文件src/api/config.js 12345678910111213export const commonParams = &#123; g_tk: 5381, inCharset: 'utf-8', outCharset: 'utf-8', notice: 0, format: 'jsonp'&#125;export const options = &#123; param: 'jsonpCallback'&#125;export const ERR_OK = 0 添加接口文件src/api/recommend.js 1234567891011121314import jsonp from 'common/js/jsonp'import &#123;commonParams, options&#125; from './config'export function getRecommend() &#123; const url = 'https://c.y.qq.com/musichall/fcgi-bin/fcg_yqqhomepagerecommend.fcg' const data = Object.assign(&#123;&#125;, commonParams, &#123; platform: 'h5', uin: 0, needNewCode: 1 &#125;) return jsonp(url, data, options)&#125; 创建 components/recommend/recommend.vue组件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;template&gt; &lt;div class="recommend" ref="recommend"&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import &#123;getRecommend&#125; from 'api/recommend' import &#123;ERR_OK&#125; from 'api/config' export default &#123; data() &#123; return &#123; recommends: [] &#125; &#125;, created() &#123; this._getRecommend() &#125;, methods: &#123; _getRecommend() &#123; getRecommend().then((res) =&gt; &#123; if (res.code === ERR_OK) &#123; this.recommends = res.data.slider &#125; &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped lang="stylus" rel="stylesheet/stylus"&gt; @import "~common/stylus/variable" .recommend position: fixed width: 100% top: 88px bottom: 0 .recommend-content height: 100% overflow: hidden .slider-wrapper position: relative width: 100% overflow: hidden .recommend-list .list-title height: 65px line-height: 65px text-align: center font-size: $font-size-medium color: $color-theme .item display: flex box-sizing: border-box align-items: center padding: 0 20px 20px 20px .icon flex: 0 0 60px width: 60px padding-right: 20px .text display: flex flex-direction: column justify-content: center flex: 1 line-height: 20px overflow: hidden font-size: $font-size-medium .name margin-bottom: 10px color: $color-text .desc color: $color-text-d .loading-container position: absolute width: 100% top: 50% transform: translateY(-50%)&lt;/style&gt; 轮播图组件实现 创建基础组件 base/slider/slider.vue12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;template&gt; &lt;div class="slider" ref="slider"&gt; &lt;div class="slider-group" ref="sliderGroup"&gt; &lt;slot&gt; &lt;/slot&gt; &lt;/div&gt; &lt;div class="dots"&gt; &lt;span class="dot" :class="&#123;active: currentPageIndex === index &#125;" v-for="(item, index) in dots"&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;&lt;/script&gt;&lt;style scoped lang="stylus" rel="stylesheet/stylus"&gt; @import "~common/stylus/variable" .slider min-height: 1px .slider-group position: relative overflow: hidden white-space: nowrap .slider-item float: left box-sizing: border-box overflow: hidden text-align: center a display: block width: 100% overflow: hidden text-decoration: none img display: block width: 100% .dots position: absolute right: 0 left: 0 bottom: 12px text-align: center font-size: 0 .dot display: inline-block margin: 0 4px width: 8px height: 8px border-radius: 50% background: $color-text-l &amp;.active width: 20px border-radius: 5px background: $color-text-ll&lt;/style&gt; 添加设置1234567891011121314151617181920export default &#123; name: 'slider', props: &#123; // 循环轮播 loop: &#123; type: Boolean, default: true &#125;, // 自动录播 autoPlay: &#123; type: Boolean, default: true &#125;, // 轮播间隔 interval: &#123; type: Number, default: 4000 &#125; &#125;&#125; 引入better-scroll并设置 123456789101112131415161718// 设置sliderGroup宽度_setSliderWidth(isResize) &#123; this.children = this.$refs.sliderGroup.children let width = 0 let sliderWidth = this.$refs.slider.clientWidth for (let i = 0; i &lt; this.children.length; i++) &#123; let child = this.children[i] addClass(child, 'slider-item') child.style.width = sliderWidth + 'px' width += sliderWidth &#125; if (this.loop &amp;&amp; !isResize) &#123; width += 2 * sliderWidth &#125; this.$refs.sliderGroup.style.width = width + 'px'&#125; 添加common/js/dom.js 1234567891011121314export function hasClass(el, className) &#123; let reg = new RegExp('(^|\\s)' + className + '(\\s|$)') return reg.test(el.className)&#125;export function addClass(el, className) &#123; if (hasClass(el, className)) &#123; return &#125; let newClass = el.className.split(' ') newClass.push(className) el.className = newClass.join(' ')&#125; 在mounted中添加方法 1234567// 一般网页刷新为17毫秒 setTimeout(() =&gt; &#123; this._setSliderWidth() if (this.autoPlay) &#123; this._play() &#125; &#125;, 20) 在recommend.vue中使用组件 12345678910// v-if确保slider中有元素后再执行&lt;div v-if="recommends.length" class="slider-wrapper" ref="sliderWrapper"&gt; &lt;slider&gt; &lt;div v-for="item in recommends"&gt; &lt;a :href="item.linkUrl"&gt; &lt;img class="needsclick" @load="loadImage" :src="item.picUrl"&gt; &lt;/a&gt; &lt;/div&gt; &lt;/slider&gt;&lt;/div&gt; 在slider.vue中初始化slider 1234567891011_initSlider() &#123; this.slider = new BScroll(this.$refs.slider, &#123; scrollX: true, scrollY: false, momentum: false, snap: true, snapLoop: this.loop, snapThreshold: 0.3, snapSpeed: 400 &#125;)&#125; 初始化dots 1234567891011121314151617// 添加methods_initDots() &#123; this.dots = new Array(this.children.length)&#125;// 在_initSlider中添加监听事件this.slider.on('scrollEnd', () =&gt; &#123; let pageIndex = this.slider.getCurrentPage().pageX if (this.loop) &#123; pageIndex -= 1 &#125; this.currentPageIndex = pageIndex if (this.autoPlay) &#123; this._play() &#125;&#125;) 添加自动播放事件 123456789101112131415// 添加methods_initDots() &#123; this.dots = new Array(this.children.length)&#125;// 在_initSlider中添加监听事件_play() &#123; let pageIndex = this.currentPageIndex + 1 if (this.loop) &#123; pageIndex += 1 &#125; this.timer = setTimeout(() =&gt; &#123; this.slider.goToPage(pageIndex, 0, 400) &#125;, this.interval)&#125; 修改_initSlider 123456789101112131415161718192021222324252627282930_initSlider() &#123; this.slider = new BScroll(this.$refs.slider, &#123; scrollX: true, scrollY: false, momentum: false, snap: true, snapLoop: this.loop, snapThreshold: 0.3, snapSpeed: 400, click: true &#125;) this.slider.on('scrollEnd', () =&gt; &#123; let pageIndex = this.slider.getCurrentPage().pageX if (this.loop) &#123; pageIndex -= 1 &#125; this.currentPageIndex = pageIndex // 添加自动播放 if (this.autoPlay) &#123; this._play() &#125; &#125;) // 手动滑动后清除定时器 this.slider.on('beforeScrollStart', () =&gt; &#123; if (this.autoPlay) &#123; clearTimeout(this.timer) &#125; &#125;)&#125; 添加窗口改变监听事件 1234567window.addEventListener('resize', () =&gt; &#123; if (!this.slider) &#123; return &#125; this._setSliderWidth(true) this.slider.refresh()&#125;) 歌单数据接口, axios 介绍和后端接口代理 在dev-server 123456789101112131415161718var apiRoutes = express.Router()apiRoutes.get('/getDiscList', function (req, res) &#123; var url = 'https://c.y.qq.com/splcloud/fcgi-bin/fcg_get_diss_by_tag.fcg' axios.get(url, &#123; headers: &#123; referer: 'https://c.y.qq.com/', host: 'c.y.qq.com' &#125;, params: req.query &#125;).then((response) =&gt; &#123; res.json(response.data) &#125;).catch((e) =&gt; &#123; console.log(e) &#125;)&#125;)app.use('/api', apiRoutes) 在src/api/recommend.js中添加接口getDiscList 123456789101112131415161718192021export function getDiscList() &#123; const url = '/api/getDiscList' const data = Object.assign(&#123;&#125;, commonParams, &#123; platform: 'yqq', hostUin: 0, sin: 0, ein: 29, sortId: 5, needNewCode: 0, categoryId: 10000000, rnd: Math.random(), format: 'json' &#125;) return axios.get(url, &#123; params: data &#125;).then((res) =&gt; &#123; return Promise.resolve(res.data) &#125;)&#125; 在recommend.vue中添加列表 123456789101112131415&lt;div class="recommend-list"&gt; &lt;h1 class="list-title"&gt;热门歌单推荐&lt;/h1&gt; &lt;ul&gt; &lt;li v-for="item in discList" class="item"&gt; &lt;div class="icon"&gt; &lt;img width="60" height="60" :src="item.imgurl"&gt; &lt;/div&gt; &lt;div class="text"&gt; // v-html:转义 &lt;h2 class="name" v-html="item.creator.name"&gt;&lt;/h2&gt; &lt;p class="desc" v-html="item.dissname"&gt;&lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; scroll 组件的抽象和应用 添加通用组件scroll 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;template&gt; &lt;div ref="wrapper"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import BScroll from 'better-scroll' export default &#123; props: &#123; probeType: &#123; type: Number, default: 1 &#125;, click: &#123; type: Boolean, default: true &#125;, data: &#123; type: Array, default: null &#125; &#125;, mounted() &#123; setTimeout(() =&gt; &#123; this._initScroll() &#125;, 20) &#125;, methods: &#123; _initScroll() &#123; if (!this.$refs.wrapper) &#123; return &#125; this.scroll = new BScroll(this.$refs.wrapper, &#123; probeType: this.probeType, click: this.click &#125;) &#125;, enable() &#123; this.scroll &amp;&amp; this.scroll.enable() &#125;, disable() &#123; this.scroll &amp;&amp; this.scroll.disable() &#125;, refresh() &#123; this.scroll &amp;&amp; this.scroll.refresh() &#125; &#125;, watch: &#123; data() &#123; setTimeout(() =&gt; &#123; this.refresh() &#125;, 20) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped lang="stylus" rel="stylesheet/stylus"&gt;&lt;/style&gt; recommend.vue中添加loadImage 1234567loadImage() &#123; // this.checkloaded:标志位, 只计算一次 if (!this.checkloaded) &#123; this.checkloaded = true this.$refs.scroll.refresh() &#125;&#125;, vue-lazyloadvue-lazyload 懒加载插件介绍和应用 main.js 1234import VueLazyload from 'vue-lazyload'Vue.use(VueLazyload, &#123; loading: require('common/image/default.png')&#125;) recommend.vue 1&lt;img width="60" height="60" v-lazy="item.imgurl"&gt; fastclick避免拦截, 加class needsclick 1&lt;img class="needsclick" @load="loadImage" :src="item.picUrl"&gt; loading 基础组件的开发和应用 添加基础组件loading.vue 在 recommend.vue中使用1234567891011121314151617181920212223242526&lt;template&gt; &lt;div class="loading"&gt; &lt;img width="24" height="24" src="./loading.gif"&gt; &lt;p class="desc"&gt;&#123;&#123;title&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: &#123; title: &#123; type: String, default: '正在载入...' &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped lang="stylus" rel="stylesheet/stylus"&gt; @import "~common/stylus/variable" .loading width: 100% text-align: center .desc line-height: 20px font-size: $font-size-small color: $color-text-l&lt;/style&gt;]]></content>
      <categories>
        <category>技术</category>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>慕课网</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js 中，7种定义组件模板的方法]]></title>
    <url>%2F2017%2F07%2F24%2FVue-js-%E4%B8%AD%EF%BC%8C7%E7%A7%8D%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E6%A8%A1%E6%9D%BF%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Vue.js 中，7种定义组件模板的方法 | Codementor 本文转载自：众成翻译译者：Mcbai审校: huangxiaolu链接：http://www.zcfy.cc/article/3644原文：https://www.codementor.io/vuejsdevelopers/7-ways-to-define-a-component-template-in-vue-js-8wxxhmxo6 有多种方式可以在vue中定义模板组件。我算了一下，至少有7种不同的方法： 字符串（String） 模板字符串（Template literal） X-Templates 内联（Inline） Render函数（Render functions） JSX 单文件组件（Single page components） 当然，可能还有更多方法! 在这篇文章里，我们将会展示每一个方法的示例，分析其优缺点，以便你能明白在特定的情形下，哪种方式是合适的。 _注意: 这篇文章最初发表在在Vue.js Developers blog上 on 2017/03/24_ 1. 字符串默认情况下，在JS文件里模板会被定义为一个字符串。但是我觉得大家都会同意这种写法很难看懂，它除了有广泛的浏览器支持之外，并没有什么优势。 123456789Vue.component('my-checkbox', &#123; template: '&lt;div class="checkbox-wrapper" @click="check"&gt;&lt;div :class="&#123; checkbox: true, checked: checked &#125;"&gt;&lt;/div&gt;&lt;div class="title"&gt;&#123;&#123; title &#125;&#125;&lt;/div&gt;&lt;/div&gt;', data() &#123; return &#123; checked: false, title: 'Check me' &#125; &#125;, methods: &#123; check() &#123; this.checked = !this.checked; &#125; &#125;&#125;); 2. 模板字符串（Template literals）通过ES6的模板字符串（反引号）语法，你在定义模板时可以直接换行，这是通过常规的JavaScript字符串没法做到的。这种写法更容易阅读，并且这种模板字符串语法得到了许多新版本浏览器的支持。当然，为了安全起见，你仍然应该把它转译为ES5的语法形式。 然而，这种方式并不完美，我发现大多数的IDE在语法高亮上做的差强人意，并且在缩进和换行等的格式方面，仍然很痛苦。 123456789101112Vue.component('my-checkbox', &#123; template: `&lt;div class="checkbox-wrapper" @click="check"&gt; &lt;div :class="&#123; checkbox: true, checked: checked &#125;"&gt;&lt;/div&gt; &lt;div class="title"&gt;&#123;&#123; title &#125;&#125;&lt;/div&gt; &lt;/div&gt;`, data() &#123; return &#123; checked: false, title: 'Check me' &#125; &#125;, methods: &#123; check() &#123; this.checked = !this.checked; &#125; &#125;&#125;); 3. X-Templates使用这种方法，你需要在index.html文件里的script标签中定义你的模板。script标签需要添加text/x-template类型作为标记，并且在定义组件时，通过id来引用。 我喜欢这种方式，它允许你使用真正的HTML标记来书写你的HTML文件，但是不足之处在于，这种方式会把模板和组件其它部分的定义分开。 123456789Vue.component('my-checkbox', &#123; template: '#checkbox-template', data() &#123; return &#123; checked: false, title: 'Check me' &#125; &#125;, methods: &#123; check() &#123; this.checked = !this.checked; &#125; &#125;&#125;); 123456&lt;script type="text/x-template" id="checkbox-template"&gt; &lt;div class="checkbox-wrapper" @click="check"&gt; &lt;div :class="&#123; checkbox: true, checked: checked &#125;"&gt;&lt;/div&gt; &lt;div class="title"&gt;&#123;&#123; title &#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/script&gt; 4. 内联模板（Inline Templates）通过给组件添加inline-template属性来告诉Vue，里面的内容就是模板，而不是把它当作是分发内容(见 slots)。 它的缺点和x-templates一样，但是有一个优点就是，它的内容就在HTML模板对应的位置，所以页面一加载就会渲染，而不用等到JavaScript执行。 12345678Vue.component('my-checkbox', &#123; data() &#123; return &#123; checked: false, title: 'Check me' &#125; &#125;, methods: &#123; check() &#123; this.checked = !this.checked; &#125; &#125;&#125;); 123456&lt;my-checkbox inline-template&gt; &lt;div class="checkbox-wrapper" @click="check"&gt; &lt;div :class="&#123; checkbox: true, checked: checked &#125;"&gt;&lt;/div&gt; &lt;div class="title"&gt;&#123;&#123; title &#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/my-checkbox&gt; 5. Render functions（渲染函数）渲染函数需要你把模板当作一个JavaScript对象来进行定义，它们是一些复杂并且抽象的模板选项。 然而，它的优点是你定义的模板更接近编译器，你可以使用所有JavaScript方法，而不仅是指令提供的那些功能。 1234567891011121314151617181920212223242526272829303132333435363738394041Vue.component('my-checkbox', &#123; data() &#123; return &#123; checked: false, title: 'Check me' &#125; &#125;, methods: &#123; check() &#123; this.checked = !this.checked; &#125; &#125;, render(createElement) &#123; return createElement( 'div', &#123; attrs: &#123; 'class': 'checkbox-wrapper' &#125;, on: &#123; click: this.check &#125; &#125;, [ createElement( 'div', &#123; 'class': &#123; checkbox: true, checked: this.checked &#125; &#125; ), createElement( 'div', &#123; attrs: &#123; 'class': 'title' &#125; &#125;, [ this.title ] ) ] ); &#125;&#125;); 6. JSXVue中最有争议性的模板选项就是JSX，一些开发者认为JSX语法太丑，不直观，而且和Vue的简洁特性背道而驰。 JSX需要事先编译，因为浏览器并不支持JSX。但是如果你需要使用渲染函数，那么JSX语法绝对是一种更简洁的定义模板的方法。 1234567891011121314Vue.component('my-checkbox', &#123; data() &#123; return &#123; checked: false, title: 'Check me' &#125; &#125;, methods: &#123; check() &#123; this.checked = !this.checked; &#125; &#125;, render() &#123; return &lt;div class="checkbox-wrapper" onClick=&#123; this.check &#125;&gt; &lt;div class=&#123;&#123; checkbox: true, checked: this.checked &#125;&#125;&gt;&lt;/div&gt; &lt;div class="title"&gt;&#123; this.title &#125;&lt;/div&gt; &lt;/div&gt; &#125;&#125;); 7. 单文件组件（Single File Components）只要你愿意在项目中使用构建工具，那么单文件组件绝对是这些方法中的首选。它们有两个最好的优点：允许你使用标记，同时把所有组件定义都写在一个文件中。 尽管单文件组件需要编译，并且一些IDE不支持这种类型文件的语法高亮，但它仍然很难被其它方法战胜。 12345678910111213141516&lt;template&gt; &lt;div class="checkbox-wrapper" @click="check"&gt; &lt;div :class="&#123; checkbox: true, checked: checked &#125;"&gt;&lt;/div&gt; &lt;div class="title"&gt;&#123;&#123; title &#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; checked: false, title: 'Check me' &#125; &#125;, methods: &#123; check() &#123; this.checked = !this.checked; &#125; &#125; &#125;&lt;/script&gt; 你可能会举出还有更多的方式来定义模板，因为你还可以使用一些模板预处理器，比如Pug！ 哪个最好?当然没有完美的方法，你应该根据你的实际情况来进行判断。我觉得一个好的程序员应该知道所有的方式，并把它们当作Vue.js技术栈里一种解决问题的工具。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 2.0 高级实战-开发移动端音乐WebApp 课程笔记（第三章 页面骨架开发）]]></title>
    <url>%2F2017%2F07%2F20%2FVue-2-0-%E9%AB%98%E7%BA%A7%E5%AE%9E%E6%88%98-%E5%BC%80%E5%8F%91%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%9F%B3%E4%B9%90WebApp-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%EF%BC%88%E7%AC%AC%E4%B8%89%E7%AB%A0-%E9%A1%B5%E9%9D%A2%E9%AA%A8%E6%9E%B6%E5%BC%80%E5%8F%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Vue 2.0 高级实战-开发移动端音乐WebApp 课程笔记（第三章 页面骨架开发）页面入口+header 组件的编写index.js 添加 viewport12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no"&gt; &lt;title&gt;vue-music&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt; &lt;!-- built files will be auto injected --&gt; &lt;/body&gt;&lt;/html&gt; package.json 添加依赖123456789&#123; "dependencies": &#123; "babel-runtime": "^6.0.0", // es语法转义 "fastclick": "^1.0.6" // 解决 移动端点击300毫秒延迟的问题 &#125;, "devDependencies": &#123; "babel-polyfill": "^6.2.0" // babel补丁，可以使用es6的一些api &#125;,&#125; /src/main.js 引入fastclick123456789101112131415161718import 'babel-polyfill'import Vue from 'vue'import App from './App'import router from './router'// 引入fastclickimport fastclick from 'fastclick'import 'common/stylus/index.styl'// 使用fastclickfastclick.attach(document.body)/* eslint-disable no-new */new Vue(&#123; el: '#app', render: h =&gt; h(App)&#125;) 创建m-header组件1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;template&gt; &lt;div class="m-header"&gt; &lt;div class="icon"&gt;&lt;/div&gt; &lt;h1 class="text"&gt;Chicken Music&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script type="text/ecmascript-6"&gt; export default &#123;&#125;&lt;/script&gt;&lt;style scoped lang="stylus" rel="stylesheet/stylus"&gt; @import "~common/stylus/variable" @import "~common/stylus/mixin" .m-header position: relative height: 44px text-align: center color: $color-theme font-size: 0 .icon display: inline-block vertical-align: top margin-top: 6px width: 30px height: 32px margin-right: 9px bg-image('logo') background-size: 30px 32px .text display: inline-block vertical-align: top line-height: 44px font-size: $font-size-large .mine position: absolute top: 0 right: 0 .icon-mine display: block padding: 12px font-size: 20px color: $color-theme&lt;/style&gt; App.vue 引入Header组件1234567891011121314151617&lt;template&gt; &lt;div id="app" @touchmove.prevent&gt; &lt;m-header&gt;&lt;/m-header&gt; &lt;/div&gt;&lt;/template&gt;&lt;script type="text/ecmascript-6"&gt; import MHeader from 'components/m-header/m-header' export default &#123; components: &#123; MHeader &#125; &#125;&lt;/script&gt;&lt;style scoped lang="stylus" rel="stylesheet/stylus"&gt;&lt;/style&gt; webpack.base.conf.js 别名配置12345678resolve: &#123; extensions: ['.js', '.vue', '.json'], alias: &#123; '@': resolve('src'), 'common': resolve('src/common'), 'components': resolve('src/components') &#125; &#125;, 路由配置+ tab 顶导组件开发router初始化12345678910111213141516171819202122232425262728293031323334import Vue from 'vue'import Router from 'vue-router'import Recommend from 'components/recommend/recommend'import Singer from 'components/singer/singer'import Rank from 'components/rank/rank'import Search from 'components/search/search'Vue.use(Router)export default new Router(&#123; routes: [ // 根路径配置 &#123; path: '/', redirect: '/recommend' &#125;, &#123; path: '/recommend', component: Recommend &#125;, &#123; path: '/singer', component: Singer &#125;, &#123; path: '/rank', component: Rank &#125;, &#123; path: '/search', component: Search &#125; ]&#125;) main.js 引入router12345678910111213141516import 'babel-polyfill'import Vue from 'vue'import App from './App'import router from './router'import fastclick from 'fastclick'import 'common/stylus/index.styl'fastclick.attach(document.body)/* eslint-disable no-new */new Vue(&#123; el: '#app', router, render: h =&gt; h(App)&#125;) App.vue 中使用router123456&lt;template&gt; &lt;div id="app" @touchmove.prevent&gt; &lt;m-header&gt;&lt;/m-header&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; 创建tab.vue 组件1234567891011121314151617181920212223242526272829303132333435363738394041&lt;template&gt; &lt;div class="tab"&gt; // tag: 渲染的标签 &lt;router-link tag="div" class="tab-item" to="/recommend"&gt; &lt;span class="tab-link"&gt;推荐&lt;/span&gt; &lt;/router-link&gt; &lt;router-link tag="div" class="tab-item" to="/singer"&gt; &lt;span class="tab-link"&gt;歌手&lt;/span&gt; &lt;/router-link&gt; &lt;router-link tag="div" class="tab-item" to="/rank"&gt; &lt;span class="tab-link"&gt;排行 &lt;/span&gt; &lt;/router-link&gt; &lt;router-link tag="div" class="tab-item" to="/search"&gt; &lt;span class="tab-link"&gt;搜索&lt;/span&gt; &lt;/router-link&gt; &lt;/div&gt;&lt;/template&gt;&lt;script type="text/ecmascript-6"&gt; export default &#123;&#125;&lt;/script&gt;&lt;style scoped lang="stylus" rel="stylesheet/stylus"&gt; @import "~common/stylus/variable" .tab display: flex height: 44px line-height: 44px font-size: $font-size-medium .tab-item flex: 1 text-align: center .tab-link padding-bottom: 5px color: $color-text-l &amp;.router-link-active .tab-link color: $color-theme border-bottom: 2px solid $color-theme&lt;/style&gt; App.vue 引入tab组件12345678910111213141516171819202122&lt;template&gt; &lt;div id="app" @touchmove.prevent&gt; &lt;m-header&gt;&lt;/m-header&gt; &lt;tab&gt;&lt;/tab&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script type="text/ecmascript-6"&gt; import MHeader from 'components/m-header/m-header' import Tab from 'components/tab/tab' export default &#123; components: &#123; MHeader, Tab &#125; &#125;&lt;/script&gt;&lt;style scoped lang="stylus" rel="stylesheet/stylus"&gt;&lt;/style&gt;]]></content>
      <categories>
        <category>技术</category>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>慕课网</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[坦然面对：应对前端疲劳]]></title>
    <url>%2F2017%2F07%2F19%2F%E5%9D%A6%E7%84%B6%E9%9D%A2%E5%AF%B9%EF%BC%9A%E5%BA%94%E5%AF%B9%E5%89%8D%E7%AB%AF%E7%96%B2%E5%8A%B3%2F</url>
    <content type="text"><![CDATA[坦然面对：应对前端疲劳 本文转载自：众成翻译译者：学会微笑审校: huangxiaolu链接：http://www.zcfy.cc/article/3509原文：https://www.smashingmagazine.com/2016/11/not-an-imposter-fighting-front-end-fatigue/ 我最近和一个做后端开发的朋友讨论我在工作之余花了多长的时间去写码和学习写码。他给我看了Uncle Bob的《Clean Code》这本书中的一段话，它将音乐家们为准备音乐会而花费的时间与开发者让代码正确执行所用的练习时间进行了比较。 我喜欢这个类比，但是我不认为我完全认同它；首先这种想法会导致疲劳。我认为如果你想进一步磨练你的技术并扩大你的技能集，那么这是很好的，但是要一天中每个小时都这样做是很难持续的。 前端疲劳是非常真实的。 我看到过一些关于JavaScript疲劳的文章，但我认为问题远不止于这种特定的语言。 先澄清一下，这篇文章不是在抱怨前端疲劳如何糟糕，以及技术发展太快—— 我喜欢技术迅速发展。同样的，我可以感受到它是如何的势不可挡，也会时不时地感觉自己要落伍了。 据我所知，这是一把双刃剑。 首先作为一个前端开发者，你认为你的技能树里应当有以下所有的技能: HTML (整洁代码，语义化标签) CSS (模块化，可伸缩) CSS 方法 (BEM, SMACSS, OOCSS) CSS 预处理器 (像LESS, SCSS, PostCSS) 现代 CSS (Flexbox, Grid) JS 现代 JS (ES6, Typescript) JS 框架 (Angular, React, Vue [更多的之后在此插入]） JS 方法 (函数式编程, 面向对象) JS 库 (Immutable, Ramda, Lodash) 响应式设计原则 测试 (TDD) 测试框架 (Jasmine, Karma) SVG WebGL 动画技术 可访问性 可用性 性能 构建工具 (Grunt, Gulp, NPM 脚本) 资源打包工具 (WebPack, Browserify) NPM 生态系统 了解不同浏览器的怪癖 敏捷方法 版本控制 (通常是 Git) 视觉设计基础 软技能，时间管理 对使用的后端语言有基本的了解。 此外，你还要涉足或展望这些技术： Service workers Progressive Web Apps (PWA) Web组件化 其次，你的日常工作可能不会完全覆盖这些技能，或者不会让你有时间去学所有技术，因此怎样才能在你的控制下去保证会所有的技能？ 开发人员听见“Progressive Web Apps” 这种术语可能会感到畏惧。新的方法和技巧导致疲劳感 —— 前端疲劳。 (图片来源) 现在作为这些技术的消费者，你可能要做的是： 订阅一打不同的开发者周刊简报 添加Twitter订阅 参加每周赶工作的前端团队 在工作之外有轻松的渠道能和一些开发者交流 按照网上的教程 (希望不是过时的) 使用视频课程培训网站像 Frontend Masters 买web开发的书 (希望不是过时的) 参加技术聚会 参加会议 参加培训课程 而作为一个贡献者，你可能要做的是： 写博客/杂志文章 演讲 直播 贡献开源项目 做自己的业余项目 最近我发现我的注意力被分散到三件事情上，我用三分之一的精力写着代码，同时戴着耳机一边听别人讨论代码，一边在Slack上跟别人聊代码。我决定适可而止——我的全部注意力都被代码所占据。我已经精疲力竭了。 虽然这肯定是极端情况，但我相信其他人也经历过类似的事情。最重要的是，你可能有一份全职工作，家庭，朋友，业余爱好。难怪我们中有那么多人感觉力不从心并且怀疑我们是否做了正确的职业选择。 我的一些前端同事都表示想要打包走人，然后换一个可以在五点结束的工作。但我认为前端工作仍旧吸引着某些的人，而如果放弃这份工作，成为一个房地产经纪人，你仍然想尽你的可能成为最好的房地产经纪人。在你的空闲时间你还是会参加房地产会议和跟踪房价趋势。很多个月以前，我在金融业工作，晚上我还在学习，阅读相关资料，想成为我所选择领域中技能最佳的人。 并不是只有这个领域需要付出巨大的精力，许多职业需要投入大量的精力并且在工作之外学习。也许前端开发的特殊之处在于技术发展得如此迅速，以至于好像有人一直在移动目标岗位。这就像每隔一天我就会收到一封电子邮件，上面写着“XYZ”技术已死。我确定这不是真的，否则我们就没有技术可用了。 生态系统处于不断变化的状态，我认为这是一件好事。就我个人而言，我喜欢扮演一个可以不断地学习、发展和督促自己的角色，但这并不是说我不会偶尔感到不知所措。 考虑到这一点，我尝试记住这些事情用来阻止我殚精竭虑，同时也有一些避免疲劳的通用建议。 我们是一样的我认识的开发者，无论是在工作中还是工作外，都是我认识的最聪明的人。但他们全都会感到不知所措。大多数人都有一些希望学习的技术清单。可能有少数人知道所有技术，而且在所有事情上都处于领先地位，但我们大多数人的处境完全相同。 我们仍然依赖Google和Stack Overflow来度过我们的一天，打开了超多的选项卡，全部是关于Web相关问题的答案。不止你一个人是这样！ 要高兴地知道你不是一个糟糕的开发人员，你只是还没有尝试过酷孩子们正在使用的东西。 是的，即使是“web名人”也有同样的困境… 你不可能知道所有的事情，而你在Twitter上追随的明星开发者在小部分的领域中表现得非常好。你会注意到，他们出名的领域恰好是他们所熟知的领域。可能也会有例外，但他们和我们一样也只是个普通人。:) 冒充者综合征是真实的，我们都有我知道有有些优秀的前端开发人员不会申请职位，因为他们在不知道工作描述要求上的所有东西的情况下，就觉得自己是个骗子。引用其中一个： “我看到的90%的JDs，会让我感觉“啊，我太落后！” 。事实上，这让我很困扰，我想留在我现在的职位，试图赚更多的钱，只是因为这样让我觉得我已经“摆脱它”。” 事实上，大部分的工作说明都是闹剧。我的朋友Bård把这些说明放在一张大的图片，来展示出前端工作要求和它们的真正含义之间的区别。 招聘广告的解释 (图片来源) (图片来源) 只要记住，会变好的。我所做的每一项工作，我都觉得自己不够深入，但最终你会习惯他们的工具和工作流程，你会学习并成为一个更好的开发人员。 不要害怕在工作中学习，掌握新技能的最佳方法是每天使用它们。 如果你有冒充者综合征，可能你是个正派的开发者，否则你就不会自觉地意识到它。 巩固基础人们很容易被耀眼的新事物分心，但是如果你的基础还不牢固，那么你所建造的东西将经受不住时间的考验。 就像我的一个好朋友曾经对我说的： “专注于基础一直是我的口头禅。你能建立良好的项目（SH！T）和解决问题，这才是最重要的，而你如何解决它们（所使用的工具）已经并将永远改变。” 例如，当react一跃成名，它似乎总是和ES6捆绑在一起，我把重点放在语言的那些改变和新特性上而不是框架本身的细微差别。一旦react不火了，我从最新的JavaScript上学到的知识将继续存在下去。你可以在原生chrome玩很多特性，而不用引入Babel陷入依赖地狱。 不用学所有的这真的很关键。我认为正在扼杀我们的不是新框架、库和模块，而是我们自己必须把它们全部学会的信念。 通过学习我发现最好的办法是专注——此刻我正在钻研ES6中的JavaScript函数式编程。 我的清单上还有很多我想学的东西，但我尽量不分心。例如，我喜欢温习我会的知识，玩Polymer，钻研一些最新的CSS技术，比如Grid，但是如果我一次开始阅读太多不同的领域，我得不到所有的信息。这些别的东西哪儿也去不了，再次看到的时候就能联想到他们。 避免在某一主题上匆忙尝试使用一切。 慢慢来，确保你完全理解它。 如果你像我一样，你会有一个不断增长的清单，但不要害怕从中剔除项目。并不是所有的事情都值得投入时间，你应该试着去认识哪些是值得学习的，哪些可能在几年内消失。花时间来学习编程的设计模式和架构技术，相比于投入在当前火的框架，在长远上来看，总是更有益的。脱离成长轨迹，过不了多久你就会迷失在追逐玩流行语的过程中。 大多数公司没有使用尖端技术现在有很多新的东西出现，web正在以惊人的速度发展，但通常企业真正在业务中开始采用这些新技术，需要很长的时间。大多数公司会等一段时间待技术成熟，并看到它在领域中被认可。 Angular 是六年前创建的，我刚开始在一家初创公司工作，他认为这是三年前的框架。Reactjs 已经有大约三年的历史了，我现在的公司仅在今年圣诞节前才开始使用它。我确信有很多其他的框架在同一时间出现或者消失。如果所有的我都要去研究，我会发疯的。 在CSS领域，flexbox在2010年就可以用了——六年前！但是浏览器到现在支持仍然有限。我们今年早些时候开始在生产环境中使用它，而且我也不认为它在其他地方被广泛使用。 我的意思是，不必急于学习所有的东西，虽然技术可能会很快发展，但你的潜在雇主正在以较慢的速度前进。你不必走在曲线的前面，只是要确保你在观察它的轨迹。 你学的越多，你会发现你不知道的也越来越多，这没关系这是完全正常的。当你刚开始的时候，你不知道你不知道什么。然后你会学习一些东西并且认为你是一个天才。然后，渐渐地，这种幻觉被打破，你开始理解事实上在这之外你有多少东西不知道。 从本质上说，你得到的经验越多，你进入的空虚就越深。你需要跟这个和平相处，否则它会消耗你。如果有的话，这种感觉会让你相信你正朝着正确的方向前进。在我们选择的职业中，你永远不会舒舒服服地学会所有前端知识。 不要把你所有的业余时间都花在学习上你很容易就感觉到你远远落后，需要每分钟都去编码和学习。这是一张通往职业疲倦的单程票。留一些时间来发展你的技能，看看你是否可以与你的老板协商一些时间来保证你的学习时间，然后用剩下的时间来做你爱做的事。 我已经分出一点写代码的时间在健身房。锻炼对你的身心都是极其重要的。尝试每天至少做20到30分钟，可以保持头脑清醒，防止疲劳。 给你的家人和朋友留出时间，尽量不要和他们谈工作！ 现在是开发者的市场目前不要担心找不到工作。此时我们正处于一个非常幸运的点，等待填充的岗位远比开发者要多。我不知道这将持续多久，但现在好好把握它！ 你可以在不知道所有技术的情况下得到一份工作。我发现，在我面试过的人中，99%的人完全是在吹牛。 最坏的情况，记住遗留代码中有黄金。如果你是一个喜欢老方式的开发人员，总是会有一些公司依赖于传统技术，需要开发人员在他们的软件上工作。 结论我希望其中的一些点有助于减轻你可能感到的一些挫折。你能做的最糟糕的事就是到达边缘，完全被烧尽，因为一旦你这样，很难恢复你对你所做的事情的热情，以及你这么做的初衷。 撸码愉快！ (aa, il)]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>成长经验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 2.0 高级实战-开发移动端音乐WebApp 课程笔记（第二章 项目准备工作）]]></title>
    <url>%2F2017%2F07%2F18%2FVue-2-0-%E9%AB%98%E7%BA%A7%E5%AE%9E%E6%88%98-%E5%BC%80%E5%8F%91%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%9F%B3%E4%B9%90WebApp-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E9%A1%B9%E7%9B%AE%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Vue 2.0 高级实战-开发移动端音乐WebApp 课程笔记（第二章 项目准备工作）需求分析vue-cli脚手架安装1vue init webpack vue-music 项目目录介绍及图标字体、公共样式等资源准备src目录介绍 src api （后端请求相关代买） common （通用静态资源） fonts image js stylus base.styl （基础样式） icon.styl （图标字体文件） index.styl （样式入口文件） mixin.styl （函数） reset.styl （重置样式文件） variable.styl （变量配置） components （通用组件） router （路由相关文件） store （vuex相关代码） App.vue main.js （入口文件） variable.styl：设计都有一定的规范，保证风格统一。这个文件定义了颜色规范和字体规范。可以方便知道开发用什么样的颜色，保证开发的方便性。]]></content>
      <categories>
        <category>技术</category>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>慕课网</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[19+ 个 JavaScript 快速编程技巧 — SitePoint]]></title>
    <url>%2F2017%2F07%2F18%2F19-%E4%B8%AA-JavaScript-%E5%BF%AB%E9%80%9F%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7-%E2%80%94-SitePoint%2F</url>
    <content type="text"><![CDATA[19+ 个 JavaScript 快速编程技巧 — SitePoint 本文转载自：众成翻译译者：myvin链接：http://www.zcfy.cc/article/3519原文：https://www.sitepoint.com/shorthand-javascript-techniques/ 这确实是一篇针对于基于 JavaScript 语言编程的开发者必读的文章。在过去几年我学习 JavaScript 的时候，我写下了这篇文章，并将其作为 JavaScript 快速编程技巧的一个重要参考。为了有助于理解，针对常规写法我也给出了相关的编程观点。 2017 年 6 月 14 日：这篇文章更新了一些基于 ES6 的速记写法。如果你想进一步了解 ES6 中有哪些新增的变化，可以注册 SitePoint Premium 并查看我们录制的视频A Look into ES6。 1. 三元操作符如果你想只用一行代码写出一个 if..else 表达式，那么这是一个很好的节省代码的方式。 常规写法： 1234567const x = 20;let answer;if (x &gt; 10) &#123; answer = 'is greater';&#125; else &#123; answer = 'is lesser';&#125; 速记法： 1const answer = x &gt; 10 ? 'is greater' : 'is lesser'; 你也可以像这样嵌套 if 表达式： 1const big = x &gt; 10 ? " greater 10" : x 2. 短路求值速记法当需要给另一个变量分配一个变量时，你可能需要确保变量不是 null、undefined 或者不为空。你可以写一个有多个 if 表达式的语句，你也可以使用短路求值。 常规写法： 123if (variable1 !== null || variable1 !== undefined || variable1 !== '') &#123; let variable2 = variable1;&#125; 速记法： 1const variable2 = variable1 || 'new'; 你不相信这样可以 work？那就自己测试下吧（把下面的代码复制粘贴到 es6console）： 1234567let variable1;let variable2 = variable1 || '';console.log(variable2 === ''); // prints truevariable1 = 'foo';variable2 = variable1 || '';console.log(variable2); // prints foo 3. 变量声明速记法在函数里声明变量时，如果需要同时声明多个变量，这种速记法能够给你节省大量的时间和空间。 常规写法： 123let x;let y;let z = 3; 速记法： 1let x, y, z=3; 4. If 判断变量是否存在速记法这可能会有些琐碎，但是值得一提。当需要用 if 判断一个变量是否为真时，赋值运算符有时候可以省略。 常规写法： 1if (likeJavaScript === true) 速记法： 1if (likeJavaScript) 注意：这两个例子并不是完全相等，只要 likeJavaScript 变量是一个 真值，该表达式就是成立的。 再给出一个例子。如果 “a” 不等于 true，如下： 常规写法： 1234let a;if ( a !== true ) &#123;// do something...&#125; 速记法： 1234let a;if ( !a ) &#123;// do something...&#125; 5. JavaScript 循环速记法如果你只想跑原生 JavaScript，不想依赖如 JQuery 或 lodash 这样的外部库，那这个小技巧会非常有用。 常规写法： 1for (let i = 0; i &lt; allImgs.length; i++) 速记法： 1for (let index in allImgs) Array.forEach 速记法： 12345678function logArrayElements(element, index, array) &#123; console.log("a[" + index + "] = " + element);&#125;[2, 5, 9].forEach(logArrayElements);// logs:// a[0] = 2// a[1] = 5// a[2] = 9 6. 短路求值如果我们不想为了只是判断一个变量是 null 或 undefined 就分配一个默认值而写六行代码，那么可以使用短路逻辑操作符完成同样的功能，而且只有一行代码。 常规写法： 123456let dbHost;if (process.env.DB_HOST) &#123; dbHost = process.env.DB_HOST;&#125; else &#123; dbHost = 'localhost';&#125; 速记法： 1const dbHost = process.env.DB_HOST || 'localhost'; 7. 十进制基数指数你可能随处可见这种写法。这是一种比较 fancy 的写法，省去了后面的一堆零。举个栗子，1e7 就意味着 1 后面跟着 7 个零。这是十进制基数指数的一种写法（JavaScript 会按照浮点类型去解释），和 10,000,000 是相等的。 常规写法： 1for (let i = 0; i &lt; 10000; i++) &#123;&#125; 速记法： 123456789for (let i = 0; i &lt; 1e7; i++) &#123;&#125;// All the below will evaluate to true1e0 === 1;1e1 === 10;1e2 === 100;1e3 === 1000;1e4 === 10000;1e5 === 100000; 8. 对象属性速记法在 JavaScript 中定义对象字面量非常简单。ES6 提供了一个更简单的定义对象属性的方法。如果 name 和 key 名字相同，那么就可以直接使用如下速记法。 常规写法： 1const obj = &#123; x:x, y:y &#125;; 速记法： 1const obj = &#123; x, y &#125;; 9. 箭头函数速记法经典的函数写法易于阅读，但是一旦将这样的函数放进回调中就会略显冗长，而且会造成一些困惑。 常规写法： 1234567891011function sayHello(name) &#123; console.log('Hello', name);&#125;setTimeout(function() &#123; console.log('Loaded')&#125;, 2000);list.forEach(function(item) &#123; console.log(item);&#125;); 速记法： 12345sayHello = name =&gt; console.log('Hello', name);setTimeout(() =&gt; console.log('Loaded'), 2000);list.forEach(item =&gt; console.log(item)); 这里需要注意的是：this 值在箭头函数和常规写法的函数里是完全不同的，所以那两个例子并不是严格等价的。查看 this article on arrow function syntax获取更多细节。 10. 隐性返回速记法我们经常使用 return 关键字来返回一个函数的结果。仅有一个表达式的箭头函数会隐性返回函数结果（函数必须省略大括号({})才能省略 return 关键字）。 如果要返回多行表达式（比如一个对象字面量），那么需要用 () 而不是 {} 来包裹函数体。这样可以确保代码作为一个单独的表达式被计算返回。 常规写法： 123function calcCircumference(diameter) &#123; return Math.PI * diameter&#125; 速记法： 123calcCircumference = diameter =&gt; ( Math.PI * diameter;) 11. 默认参数值你可以使用 if 表达式为函数参数定义默认值。在 ES6 中，你可以在函数声明的时候直接定义默认值。 常规写法： 1234567function volume(l, w, h) &#123; if (w === undefined) w = 3; if (h === undefined) h = 4; return l * w * h;&#125; 速记法： 123volume = (l, w = 3, h = 4 ) =&gt; (l * w * h);volume(2) //output: 24 12. 模板字面量你是不是已经厌倦了使用 &#39; + &#39; 来将多个变量拼接成一个字符串？难道就没有更简单的方式来完成吗？如果你可以使用 ES6 的话，那么恭喜你，你要做的只是使用反引号和 ${} 来包裹你的变量。 常规写法： 123const welcome = 'You have logged in as ' + first + ' ' + last + '.'const db = 'http://' + host + ':' + port + '/' + database; 速记法： 123const welcome = `You have logged in as $&#123;first&#125; $&#123;last&#125;`;const db = `http://$&#123;host&#125;:$&#123;port&#125;/$&#123;database&#125;`; 13. 解构赋值速记法如果你正在使用任意一种流行的 web 框架，那么你很有可能会使用数组或者对象字面量形式的数据在组件和 API 之间传递信息。一旦组件接收到数据对象，你就需要将其展开。 常规写法： 123456789const observable = require('mobx/observable');const action = require('mobx/action');const runInAction = require('mobx/runInAction');const store = this.props.store;const form = this.props.form;const loading = this.props.loading;const errors = this.props.errors;const entity = this.props.entity; 速记法： 123import &#123; observable, action, runInAction &#125; from 'mobx';const &#123; store, form, loading, errors, entity &#125; = this.props; 你甚至可以给变量重新分配变量名： 1const &#123; store, form, loading, errors, entity:contact &#125; = this.props; 14. 多行字符串速记法如果你需要在代码中写多行字符串，那么你可能会这样写： 常规写法： 123456const lorem = 'Lorem ipsum dolor sit amet, consectetur\n\t' + 'adipisicing elit, sed do eiusmod tempor incididunt\n\t' + 'ut labore et dolore magna aliqua. Ut enim ad minim\n\t' + 'veniam, quis nostrud exercitation ullamco laboris\n\t' + 'nisi ut aliquip ex ea commodo consequat. Duis aute\n\t' + 'irure dolor in reprehenderit in voluptate velit esse.\n\t' 但是有一种更简单的方法：使用反引号。 速记法： 123456const lorem = `Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse.` 15. 展开运算符速记展开运算符是在 ES6 中引入的，它的多种应用场景使得 JavaScript 代码使用起来更高效、更有趣。它可以用来替换某些数组函数。展开运算符写起来很简单，就是三个点。 常规写法： 1234567// joining arraysconst odd = [1, 3, 5];const nums = [2 ,4 , 6].concat(odd);// cloning arraysconst arr = [1, 2, 3, 4];const arr2 = arr.slice() 速记法： 12345678// joining arraysconst odd = [1, 3, 5 ];const nums = [2 ,4 , 6, ...odd];console.log(nums); // [ 2, 4, 6, 1, 3, 5 ]// cloning arraysconst arr = [1, 2, 3, 4];const arr2 = [...arr]; 和 concat() 函数不同，你可以在另一个数组里的任意位置插入一个数组。 12const odd = [1, 3, 5 ];const nums = [2, ...odd, 4 , 6]; 你也可以将展开运算符和 ES6 解析赋值结合起来使用： 1234const &#123; a, b, ...z &#125; = &#123; a: 1, b: 2, c: 3, d: 4 &#125;;console.log(a) // 1console.log(b) // 2console.log(z) // &#123; c: 3, d: 4 &#125; 16. 强制参数速记法如果没有传值的话，JavaScript 默认会将函数参数设置为 undefined。一些其他的编程语言会抛出警告或错误。为了强制给参数赋值，如果参数没有定义的话，你可以使用 if 表达式抛出错误，或者可以使用“强制参数速记法”。 常规写法： 123456function foo(bar) &#123; if(bar === undefined) &#123; throw new Error('Missing parameter!'); &#125; return bar;&#125; 速记法： 1234567mandatory = () =&gt; &#123; throw new Error('Missing parameter!');&#125;foo = (bar = mandatory()) =&gt; &#123; return bar;&#125; 17. Array.find 速记法如果你曾经使用原生 JavaScript 写一个查找函数，你可能会使用 for 循环。在 ES6 中，你可以使用数组的一个新方法 find()。 常规写法： 12345678910111213const pets = [ &#123; type: 'Dog', name: 'Max'&#125;, &#123; type: 'Cat', name: 'Karl'&#125;, &#123; type: 'Dog', name: 'Tommy'&#125;,]function findDog(name) &#123; for(let i = 0; i&lt;pets.length; ++i) &#123; if(pets[i].type === 'Dog' &amp;&amp; pets[i].name === name) &#123; return pets[i]; &#125; &#125;&#125; 速记法： 12pet = pets.find(pet =&gt; pet.type ==='Dog' &amp;&amp; pet.name === 'Tommy');console.log(pet); // &#123; type: 'Dog', name: 'Tommy' &#125; 18. Object [key] 速记法你知道 Foo.bar 可以写成 Foo[&#39;bar&#39;] 吧。一开始，似乎并没有原因解释说为什么应该像这样写。但是这种写法可以让你编写可重用代码。 考虑下一个验证函数的简单例子： 123456789function validate(values) &#123; if(!values.first) return false; if(!values.last) return false; return true;&#125;console.log(validate(&#123;first:'Bruce',last:'Wayne'&#125;)); // true 这个函数完美的实现了所需的功能。但是，请考虑一个场景：你有许多表单需要验证，并且不同的域有不同的验证规则。那创建一个在运行时被配置的通用验证函数岂不是更好？ 速记法： 123456789101112131415161718192021222324// object validation rulesconst schema = &#123; first: &#123; required:true &#125;, last: &#123; required:true &#125;&#125;// universal validation functionconst validate = (schema, values) =&gt; &#123; for(field in schema) &#123; if(schema[field].required) &#123; if(!values[field]) &#123; return false; &#125; &#125; &#125; return true;&#125;console.log(validate(schema, &#123;first:'Bruce'&#125;)); // falseconsole.log(validate(schema, &#123;first:'Bruce',last:'Wayne'&#125;)); // true 现在创建了一个可以在所有的表单里重用的验证函数，而不必为每个表单单独写一个特定的验证函数。 19. 双位取反运算符速记法逐位运算符是你在刚学习 JavaScript 时会学到的一个特性，但是如果你不处理二进制的话，基本上是从来都不会用上的。 但是，双位运算符有一个非常实用的使用场景：可以用来代替 Math.floor。双位取反运算符的优势在于它执行相同操作的速度更快。你可以在这里查看更多关于位运算符的知识。 常规写法： 1Math.floor(4.9) === 4 //true 速记法： 1~~4.9 === 4 //true 20. 还有其他的小技巧？我确实喜欢这些小技巧，也乐于发现更多的小技巧。如果你有什么想说的话，就直接留言吧！]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 2.0 高级实战-开发移动端音乐WebApp 课程笔记（第一章 课程内容介绍）]]></title>
    <url>%2F2017%2F07%2F16%2FVue-2-0-%E9%AB%98%E7%BA%A7%E5%AE%9E%E6%88%98-%E5%BC%80%E5%8F%91%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%9F%B3%E4%B9%90WebApp-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%EF%BC%88%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9%E4%BB%8B%E7%BB%8D%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Vue 2.0 高级实战-开发移动端音乐WebApp 课程笔记（第一章 课程内容介绍）应用的分层逻辑结构模型(总体结构) 课程收获 了解一个中度复杂的应用开发 拆分目录 设计路由 设计数据结构 掌握vue.js的高级应用 vuex的状态管理 组件间的数据共享 在路由间跳转并传递复杂的数据 懒加载 学会组件化, 模块化的开发方式 什么时候该抽象一个组件, 该抽象基础组件还是通用组件还是应用组件 如何设计和开发一个组件 了解原生App体验交互的实现原理]]></content>
      <categories>
        <category>技术</category>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>慕课网</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scss基础]]></title>
    <url>%2F2017%2F07%2F16%2Fscss%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[scss基础找一个点看官网的demo入手，入手后边用边找对应的API。只要学会最基本的东西，如何编译，嵌套的写法，如何计算。就和学js一样，最开始只要学习变量，判断，循环，随着项目过程，不断的看api，慢慢就熟了，然后可以看一看背后的东西。只要知道是什么，和最基本的东西就行。 前端技术发展的很快，要不断的学一些新东西，这样以这些东西为基础的新东西发展出来时，才能很快知道和学习。 变量scss中可以定义变量，方便统一修改和维护。123456789//scss style//-----------------------------------$fontStack: Helvetica, sans-serif;$primaryColor: #333;body &#123; font-family: $fontStack; color: $primaryColor;&#125; 123456//css style//-----------------------------------body &#123; font-family: Helvetica, sans-serif; color: #333;&#125; 嵌套scss可以进行选择器的嵌套，表示层级关系，看起来很优雅整齐。 1234567891011121314151617//scss style//-----------------------------------nav &#123; ul &#123; margin: 0; padding: 0; list-style: none; &#125; li &#123; display: inline-block; &#125; a &#123; display: block; padding: 6px 12px; text-decoration: none; &#125;&#125; 1234567891011121314151617//css style//-----------------------------------nav ul &#123; margin: 0; padding: 0; list-style: none;&#125;nav li &#123; display: inline-block;&#125;nav a &#123; display: block; padding: 6px 12px; text-decoration: none;&#125; 导入123456789101112scss中如导入其他scss文件，最后编译为一个css文件，优于纯css的@import//scss style//-----------------------------------// _reset.scsshtml,body,ul,ol &#123; margin: 0; padding: 0;&#125; 12345678910//scss style//-----------------------------------// base.scss @import 'reset';body &#123; font-size: 100% Helvetica, sans-serif; background-color: #efefef;&#125; 1234567891011//css style//-----------------------------------html, body, ul, ol &#123; margin: 0; padding: 0;&#125;body &#123; background-color: #efefef; font-size: 100% Helvetica, sans-serif;&#125; mixinscss中可用mixin定义一些代码片段，且可传参数，方便日后根据需求调用。从此处理css3的前缀兼容轻松便捷。 1234567891011//scss style//-----------------------------------@mixin box-sizing ($sizing) &#123; -webkit-box-sizing:$sizing; -moz-box-sizing:$sizing; box-sizing:$sizing;&#125;.box-border&#123; border:1px solid #ccc; @include box-sizing(border-box);&#125; 12345678//css style//-----------------------------------.box-border &#123; border: 1px solid #ccc; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box;&#125; 扩展/继承scss可通过@extend来实现代码组合声明，使代码更加优越简洁。 12345678910111213141516171819202122//scss style//-----------------------------------.message &#123; border: 1px solid #ccc; padding: 10px; color: #333;&#125;.success &#123; @extend .message; border-color: green;&#125;.error &#123; @extend .message; border-color: red;&#125;.warning &#123; @extend .message; border-color: yellow;&#125; 12345678910111213141516171819//css style//-----------------------------------.message, .success, .error, .warning &#123; border: 1px solid #cccccc; padding: 10px; color: #333;&#125;.success &#123; border-color: green;&#125;.error &#123; border-color: red;&#125;.warning &#123; border-color: yellow;&#125; 运算scss可进行简单的加减乘除运算等 12345678910111213//scss style//-----------------------------------.container &#123; width: 100%; &#125;article[role="main"] &#123; float: left; width: 600px / 960px * 100%;&#125;aside[role="complimentary"] &#123; float: right; width: 300px / 960px * 100%;&#125; 123456789101112131415//css style//-----------------------------------.container &#123; width: 100%;&#125;article[role="main"] &#123; float: left; width: 62.5%;&#125;aside[role="complimentary"] &#123; float: right; width: 31.25%;&#125; 颜色scss中集成了大量的颜色函数，让变换颜色更加简单。 12345678910//scss style//-----------------------------------$linkColor: #08c;a &#123; text-decoration:none; color:$linkColor; &amp;:hover&#123; color:darken($linkColor,10%); &#125;&#125; 123456789//css style//-----------------------------------a &#123; text-decoration: none; color: #0088cc;&#125;a:hover &#123; color: #006699;&#125; compasscompass由scss的核心团队成员Chris Eppstein创建，是一个非常丰富的样式框架，包括大量定义好的mixin，函数，以及对scss的扩展。]]></content>
      <tags>
        <tag>scss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime快捷键设置]]></title>
    <url>%2F2017%2F07%2F16%2Fsublime%E5%BF%AB%E6%8D%B7%E9%94%AE%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[sublime快捷键设置快捷键设计原则 尽量不改变原有快捷键 手指跨幅不要太大 语义化表达 相反操作用ctrl和ctrl+alt操作 快捷键配置1234567891011121314151617181920212223[ // 字母大小写 &#123; "keys": ["ctrl+k", "ctrl+u"], "command": "title_case" &#125;, &#123; "keys": ["ctrl+u", "ctrl+u"], "command": "upper_case" &#125;, &#123; "keys": ["ctrl+k", "ctrl+l"], "command": "lower_case" &#125;, // 折叠代码操作 &#123; "keys": ["ctrl+shift+["], "command": "fold" &#125;, &#123; "keys": ["ctrl+shift+]"], "command": "unfold" &#125;, &#123; "keys": ["ctrl+k", "ctrl+1"], "command": "fold_by_level", "args": &#123;"level": 1&#125; &#125;, &#123; "keys": ["ctrl+k", "ctrl+2"], "command": "fold_by_level", "args": &#123;"level": 2&#125; &#125;, &#123; "keys": ["ctrl+k", "ctrl+3"], "command": "fold_by_level", "args": &#123;"level": 3&#125; &#125;, &#123; "keys": ["ctrl+k", "ctrl+4"], "command": "fold_by_level", "args": &#123;"level": 4&#125; &#125;, &#123; "keys": ["ctrl+k", "ctrl+5"], "command": "fold_by_level", "args": &#123;"level": 5&#125; &#125;, &#123; "keys": ["ctrl+k", "ctrl+6"], "command": "fold_by_level", "args": &#123;"level": 6&#125; &#125;, &#123; "keys": ["ctrl+k", "ctrl+7"], "command": "fold_by_level", "args": &#123;"level": 7&#125; &#125;, &#123; "keys": ["ctrl+k", "ctrl+8"], "command": "fold_by_level", "args": &#123;"level": 8&#125; &#125;, &#123; "keys": ["ctrl+k", "ctrl+9"], "command": "fold_by_level", "args": &#123;"level": 9&#125; &#125;, &#123; "keys": ["ctrl+k", "ctrl+0"], "command": "unfold_all" &#125;, &#123; "keys": ["ctrl+alt+k", "ctrl+alt+0"], "command": "fold_all" &#125;, &#123; "keys": ["ctrl+k", "ctrl+j"], "command": "unfold_all" &#125;, &#123; "keys": ["ctrl+alt+k", "ctrl+alt+j"], "command": "fold_tag_attributes" &#125;,] 快捷键导航/跳转ctrl+p:根据文件名快速打开文件+@:跳转到所定义模块+#:跳转到关键字+:跳转到行 tabsctrl+shift+t:打开最近关闭的tabctrl+pgUp:逆序显示tabctrl+pgUp:顺序序显示tabctrl+w:关闭tab 分屏alt+shift+2alt+shift+1 编辑删除ctrl+x:删除行ctrl+kk:删除光标后所有内容ctrl+j:将下一行与当前行连接 移位ctrl+回车:在当前行下方另起一行ctrl+shift+回车:在当前行上方另起一行ctrl+shift+上下键:交换上下行 选中ctrl+方向键:选中ctrl+shift+左右键:以词为单位选中ctrl+shift+m:选中封闭模块内容ctrl+m:跳转到模块处ctrl+d:选中相同词ctrl+K,ctrl+d:跳过最后选中的词alt+f3:选择全部相同单词ctrl+l:选中行ctrl+shift+l 查询ctrl+f:查找ctrl+h:替换 标签ctrl+f2:设置书签f2:上一个书签shift:下一个书签ctrl+shift+f2:清除所有书签 文本操作ctrl+ku 首字母大小写ctrl+uu 大写ctrl+kl 小写 代码折叠ctrl+shift+[:折叠ctrl+shift+]:取消折叠ctrl+k, ctrl+0:取消所有折叠ctrl+alt+k, ctrl+alt+0:折叠全部ctrl+k, ctrl+j:取消所有折叠ctrl+alt+k, ctrl+alt+j:折叠所有标签]]></content>
      <tags>
        <tag>sublime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime常用插件]]></title>
    <url>%2F2017%2F07%2F16%2Fsublime%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[sublime常用插件设置(setting)123456789101112131415&#123; "auto_complete_triggers": [ &#123; "characters": "1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.&lt;", "selector": "text.html" &#125; ], "font_size": 14, "ignored_packages": [ "Vintage" ], "tab_size": 2&#125; 插件安装插件1ctrl+shirt+p install package control 常用插件emmet介绍：仿选择器语法生成代码 docBlock介绍：自动补全注释 html/css/js prettify介绍：整理代码 CSScomb介绍：规范css，整理css顺序配置网站：http://csscomb.com/config配置： 1234567891011121314151617181920212223242526272829&#123; "node-path" : "C:\\Program Files\\nodejs.node.exe", "config": &#123; "remove-empty-rulesets": true, "always-semicolon": true, "color-case": "lower", "block-indent": "\t", "color-shorthand": true, "element-case": "lower", "eof-newline": false, "leading-zero": false, "quotes": "single", "sort-order-fallback": "abc", "space-before-colon": "", "space-after-colon": " ", "space-before-combinator": " ", "space-after-combinator": " ", "space-between-declarations": "\n", "space-before-opening-brace": " ", "space-after-opening-brace": "\n", "space-after-selector-delimiter": "\n", "space-before-selector-delimiter": "", "space-before-closing-brace": "\n", "strip-spaces": true, "tab-size": true, "unitless-zero": true, "vendor-prefix-align": true &#125;&#125; file header介绍：添加文件header jQuery介绍：jquery代码提示 Bootstrap 3 Snippets介绍：bootstrap3 代码片段 SCSS介绍：scss代码提示 ES6-Toolkit介绍：es6转es5,es6代码片段 SideBarEnhancements介绍：打开浏览器 Terminal介绍：打开命令行工具]]></content>
      <tags>
        <tag>sublime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令]]></title>
    <url>%2F2017%2F07%2F16%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Linux常用命令命令的基本格式命令 [选项] [参数] 注意:个别命令使用不遵循此格式 当有多个选项时,可以写在一起 简化选项等于完整选项 -a 等于 –all 查询目录中内容:lsls [选项] [文件或目录]选项：-a 显示所有文件，包含隐藏文件-l 显示详细信息-d 查看目录本身属性-h 人性化显示文件大小-i 显示inode节点（储存时生成的编码，格式化硬盘时候，分成等大的内存块4k,同时生成相应的节点表） 文件处理命令目录和文件处理命令建立目录：mkdir mkdir -p [目录名]-p 递归创建命令英文原意:make directories 切换所在目录：cd cd [目录]命令英文原意:change directory 简化命令cd和cd ~进入当前用户的家目录cd - 进入上次目录cd .. 进入上一级目录cd . 进入当前目录 Ctrl+L 清屏tab 可以补全目录或命令 查询所在目录位置：pwd命令英文原意:print working directory 删除空目录：rmdir rmdir [目录名]命令英文原意:remove empty directories 删除文件或目录：rm rm -rf [目录名]命令英文原意:remove 选项：-r 删除目录-f 强制 复制命令：cp cp [选项] [原文件或目录] [目标目录]命令英文原意：copy 选项：-r 复制目录-p 连带文件属性复制-d 若源文件是链接文件,则复制链接属性-a 相当于 -pdr 剪切或改名命令：mv mv [原文件或目录] [目标目录]命令英文原意：move ll 等于 ls -l 常用目录的作用 /根目录 /bin命令保存目录（普通用户就可以读取的命令） /boot启动目录，启动相关文件 /dev设备文件保存目录 /etc配置文件保存目录 /home普通用户的家目录 /lib系统库保存目录 /mnt系统挂载目录 /media挂载目录 /root超级用户的家目录 /tmp临时目录 /sbin命令保存目录（超级用户才能使用的目录） /proc直接写入内存的 /sys /usr系统软件资源目录 /usr/bin/系统命令（普通用户） /usr/sbin/（超级用户） /var系统相关文档内容 链接命令 ln -s [原文件] [目标文件]命令英文原意：link 功能描述：生成链接文件 选项： -s 创建软链接 硬链接特征：1、拥有相同的i节点和存储block块，可以看作是同一个文件2、可通过i节点识别3、不能跨分区4、不能针对目录使用 软链接特征：1、类似Windows快捷方式2、软链接拥有自己的i节点和Block块，但是数据块中只保存原文件的文件名和i节点号，并没有实际的文件数据3、lrwxrwxrwx l 软链接4、修改任意文件，另一个文件都改变5、删除原文件，软链接不能使用 文件搜索命令文件搜索命令 locate locate 文件名在后台数据库中安文件名搜索，搜索速度更快 updatedb更新数据库 命令搜索命令 whereis 和 which whereis 命令名搜索命令所在路径及帮助文档所在位置选项：-b：只查找可执行文件-m：只查找帮助文档 which 文件名搜索命令所在路径及别名 文件搜索命令 find find [搜索范围] [搜索条件]搜索文件 find / -name install.log避免大范围搜索，会非常消耗系统资源find是在系统当中搜索符合条件的文件名。如果需要匹配，使用通配符匹配，通配符是完全匹配。 find / -iname install.log不区分大小写 find / -user install.log按照所有者搜索 find /root -nouser查找没有所有者的文件 find /var/log/ -mtime +10查找10天亲修改的文件 +10 10天以前-10 10天内10 10天当天-mtime 修改文件内容-ctime 修改文件属性-atime 文件访问时间 find . -size 25k查找文件大小是25KB的文件 -25k 小于25KB的文件25k 等于25KB的文件+25k 大于25KB的文件 find . -inum 262422查找i几点是262422的文件 find /ect -size +20k -a -size -50k查找/etc/目录下，大于20KB并且小于50KB的文件-a and 逻辑与-o or 逻辑或 find /ect -size +20k -a -size -50k -exec ls -lh {} \;查找/etc/目录下，大于20KB并且小于50KB的文件，并显示详细信息-exec/-ok 命令 {} \; 对搜索结果执行操作 字符串搜索命令 grep grep [选项] 字符串 文件名在文件当中匹配符合条件的字符串 选项：-i 忽略大小写-v 排除指定的字符串 帮助命令man 命令 查看命令拥有哪个级别的帮助man -f 命令相当于whereis 命令 举例：man -5 passwd 查看和命令相关的所有帮助man -k 命令相当于apropos 命令 选项帮助命令 –help shell内部命令帮助help shell内部命令 详细命令infoinfo 命令回车：进入子帮助页面u：进入上层页面n：进入下一个帮助小节p：进入上一个帮助小节q：退出]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL运算符和函数]]></title>
    <url>%2F2017%2F07%2F16%2FMySQL%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[MySQL运算符和函数字符函数 函数名称 描述 CONCAT() 字符连接 CONCAT_WS() 使用指定的分隔符进行字符连接 FORMAT() 数字格式化 LOWEER() 转换成小写字母 UPPER() 转换成大写字母 LEFT() 获取左侧字符 RIGHT() 获取右侧字符 LENGTH() 获取字符串长度 LTRIM() 删除前导空格 RTRIM() 删除后续空格 TRIM() 删除前导和后续空格 SUBSTRING() 字符串截取 [NOT] LIKE() 匹配模式 REPLACE() 字符串替换 数值运算符与函数 函数名称 描述 CEIL() 进一取整 DIV 整数除法 FLOOR() 舍一取整 MOD 取余数（取模） POWER() 幂运算 ROUND() 四舍五入 TRUNCATE() 字数截取 比较运算符与函数 函数名称 描述 [NOT] BETWEEN…AND… [不]在范围之内 [NOT] IN() [不]在列出值范围内 IS [NOT] NULL [不]为空 日期时间函数 函数名称 描述 NOW() 当前日期和时间 CURDATE() 当前日期 CURTIME() 当前时间 DATE_ADD() 日期变化 DATEDIFF() 日期差值 DATE_FORMAT() 日期格式化 信息函数 函数名称 描述 CONNECTION_ID() 连接ID DATEBASE() 当前数据库 LAST_INSERT_ID() 最后插入记录的ID号 USER() 当前用户 VERSION() 版本信息 聚合函数 函数名称 描述 AVG() 平均值 COUNT() 计数 MAX() 最大值 MIN() 最小值 SUM() 求和 加密函数 函数名称 描述 MD5() 信息摘要算法 PASSWORD() 密码算法]]></content>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bash示例和书写流程]]></title>
    <url>%2F2017%2F07%2F14%2Fbash%E7%A4%BA%E4%BE%8B%E5%92%8C%E4%B9%A6%E5%86%99%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[bash示例和书写流程新建文件test.sh1touch test.sh 添加可执行权限1$ chmod +x test.sh 编辑test.sh，test.sh内容如下：12345#!/bin/bashecho "hello bash"exit 0 说明： #!/bin/bash : 它是bash文件声明语句，表示是以/bin/bash程序执行该文件。它必须写在文件的第一行！ echo “hello bash” : 表示在终端输出“hello bash” exit 0 : 表示返回0。在bash中，0表示执行成功，其他表示失败。 执行bash脚本1234./test.sh#或者sh test.shbash test.sh 在终端输出“bash hello” 参考：Linux bash总结]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL语句]]></title>
    <url>%2F2017%2F07%2F12%2FMySQL%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[MySQL语句初涉MySQLMySQL的安装与配置default-character-set=utf8character-set-server=utf8 MySQL常用命令以及语法规范MySQL语句规范：关键字与函数名称全部大写；数据库名称、表名称、字段名称全部小写；SQL语句必须以分号结尾； 修改提示符：PROMPT 参数 描述 \D 完整的日期 \d 当前数据库 \h 完整的服务器名称 \u 当前用户 数据类型整型： Col1 存储范围 字节 tinyint 有符号：-128到127 （-2的7次方到 2的7次方-1） 无符号 ：0-255 （0-2的8次方-1） 1 smallint 有符号：-128到127 （-2的7次方到 2的7次方-1）无符号 ：0-255 （0-2的8次方-1） 2 mediumint 有符号：-8388608到8388608 （-2的23次方到 2的23次方-1）无符号 ：0-16777215 （0-2的24次方-1） 3 int 有符号：-2147483648到2147483648 （-2的31次方到 2的31次方-1）无符号 ：0-4294967295 （0-2的32次方-1） 4 bigint 有符号：-9223372036854775808到9223372036854775808 （-2的63次方到 2的63次方-1）无符号 ：0-18446744073709551616 （0-2的63次方-1） 8 1.整形1.1 tinyint 1字节有符号：-128到127 （-2的7次方到 2的7次方-1）无符号 ：0-255 （0-2的8次方-1） 1.2 smallint 2字节有符号：-32768到32768 （-2的15次方到 2的15次方-1）无符号 ：0-65535 （0-2的16次方-1） mediumint 3字节有符号：-8388608到8388608 （-2的23次方到 2的23次方-1）无符号 ：0-16777215 （0-2的24次方-1） int 4字节有符号：-2147483648到2147483648 （-2的31次方到 2的31次方-1）无符号 ：0-4294967295 （0-2的32次方-1） bigint 8字节 有符号：-9223372036854775808到9223372036854775808 （-2的63次方到 2的63次方-1）无符号 ：0-18446744073709551616 （0-2的63次方-1） 操作数据库创建数据库： CREATE {DATABASE | SCHEMA}[IF NOT EXISTS] db_name [[DEFAULT] CHARACTER SET [=] charset_name]; 修改数据库： ALTER {DATABASE|SCHEMA}[db_name] [DEFAULT] [CHARACTER SET [=] charset_name]; 删除数据库： DROP {DATABASE|SCHEMA}[IF EXISTS] db_name; 查看数据库： SHOW DATABASE; 警告信息： SHOW WARNINGS; SHOW CREATE DATABASE t1; ##基础操作 INSERT 插入 INSERT INTO1INSERT [INTO] table_name [(column_name,...)] &#123;VALUES|VALUE&#125; (&#123;expr|DEFAULT&#125;,...),(...),...; 此方法比较常用，可以一次性插入多条记录，并且可以输入表达式甚至是函数，但是无法进行子查询。 INSERT SET1INSERT [INTO] tb1_name SET col_name=&#123;expr|DEFAULT&#125;,...; 与第一种方式的区别在于，此方法可以使用子查询（SubQuery）;且只能一次性插入一条记录。 INSERT SELECT1INSERT [INTO] table_name [(column_name,...)] SELECT...; 此方法可以将查询结果插入到指定数据表中 举例：1INSERT test（username） SELECT username FROM users WHERE age &gt;=30; UPDATE 更新（单表）1UPDATE [LOW_PRIORITY] [IGNORE] table_reference SET col_name1=&#123;expr1|DEFAULT&#125;[,col_name2=&#123;expr2|DEFAULT&#125;]...[WHERE where_condition]; 一般来说要用WHERE指定位置，不然所有数据都会被更新. 举例：1UPDATE users SET age = age + 5 - id,sex = 0; //更新多个字段的值1UPDATE users SET age = age+ 10 WHERE id % 2=0; //更新id为偶数的位置age的值 DELETE 删除（单表）1DELETE FROM tbl_name [WHERE where_conditon]; SELECT 查找123456789SELECT select_expr [,select_expr ...] --只查找某一个函数或表达式[FROM table_references --查询表名[WHERE where_conditon] --查询条件[GROUP BY &#123;col_name|position&#125; [ASC|DESC],...] --按某个字段进行分组，相同的只显示第一个[HAVING where_conditon] --分组时，给出显示条件[ORDER BY &#123;col_name|expr|position&#125; [ASC|DESC],...] --排序[LIMIT &#123;[offset,]row_count|row_count OFFSET offset&#125;] --限制返回数量] 每一个表达式表示想要的一列，必须至少有一个多个列之间以英文逗号分隔星号( )表示所以列 tbl_name.可以表示命名表的所有列查询表达式可以使用[As]alias_name为其赋予别名别名可用于GROUP BY，ORDRE BY或HAVING子句 SELECT 字段出现顺序影响结果集出现顺序，字段别名也影响结果集字段别名。 利用GROUP BY 分组 添加分组条件 [HAVING where_condition]要么为一个聚合函数，要么出现在SELECT 条件中。（聚合函数：max(),min(),avg(),sum(),count() 永远只有一个返回结果） ##子查询和连接 子查询简介 子查询是指出现在【其他SQL语句内】的SELECT子句eg：SELECT FROM t1 WHERE column1 = (SELECT column1 FROM t2);其中，SELECT FROM t1 …称为Outer Query（外查询或者Outer Statement）SELECT column1 FROM t2 称为Sub Query（子查询） 子查询可以返回标量、一行、一列或者子查询。 使用比较运算符的子查询 子查询查询出的结果出现多个时，使用ANY\SOME（符合其中一个），ALL（全部符合）来来修饰。 [NOT] IN 的子查询=ANY 等价于 IN!=ALL或&lt;&gt;ANY等价于NOT IN 使用[NOT]EXISTS的子查询（不常用）：若子查询返回任何行，则返回TRUE，否则为FALSE。 使用INSERT…SELECT插入记录INSERT [INTO] tbl_name SET col_name={exprDEFAULT},... --可以使用子查询 INSERT [INTO] tbl_name [(col_name,...)] SELECT ... --将查询结果写入数据表 eg：DESC tdb_goods_cates; //显示出tdb_goods_cates表中的项目名称，与SHOW COLUMNS FROM tdb_goods_cates;作用相同 INSERT tdb_goods_cates(cate_name) SELECT goods_cate FROM tdb_goods GROUP BY goods_cate;//在表tdb_goods_cates中插入tdb_goods中的cate 多表更新UPDATE table_references SET col_name1={expr1|DEFAULT} [,col_name2={expr2|DEFAULT}]... [WHERE where_condition] INNER JOIN,内连接在MySQL中，JOIN, CROSS JOIN 和 INNER JOIN 是等价的。LEFT [OUTER] JOIN ,左外连接RIGHT [OUTER] JOIN,右外连接 update tdb_goods inner join tdb_goods_cates on goods_cate=cate_name set goods_cate=cate_id; 多表更新（一步到位）建表、查询、写入三合一 CREATE TABLE tdb_goods_brands ( brand_id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT, brand_name VARCHAR(40) NOT NULL ) SELECT brand_name FROM tdb_goods GROUP BY brand_name; 多表更新 UPDATE tdb_goods INNER JOIN tdb_goods_brands ON tdb_goods.brand_name = tdb_goods_brands.brand_name SET tdb_goods.brand_name = tdb_goods_brands.brand_id; 通过ALTER TABLE语句修改数据表结构ALTER TABLE tdb_goodsCHANGE goods_cate cate_id SMALLINT UNSIGNED NOT NULL,CHANGE brand_name brand_id SMALLINT UNSIGNED NOT NULL; 外键，不一定是物理的外键，逻辑的外键也行，当然，物理外键更能保证数据的完整性和一致性 注意：数字类型的字段占用的空间更小，查询的效率也更高 连接语法结构MySQL在SELECT语句、多表更新、多表删除语句中支持JOIN操作。语法结构 table_reference A {[INNER|CROSS] JOIN | {LEFT|RIGHT} [OUTER] JOIN} table_reference B ON condition_expr 数据表参照table_referencetbl_name [[AS] alias] table_subquery [AS] alias数据表可以使用tbl_name AS alias_name 或 tbl_name alias_name赋予别名。table_subquery可以作为子查询使用在FROM子句中，这样的子查询必须为其赋予别名。 内连接INNER JOIN1、内连接：在MySQL中JOIN,INNER JOIN,CROSS JOIN是等价的2、外连接：LEFT JOIN左外连接；RIGHT JOIN右外连接3、连接条件：使用ON设定连接条件，也可以用WHERE代替· ON：设定连接条件· WHERE：进行结果集记录的过滤4：内连接是返回左表及右表符合连接条件的记录eg： SELECT * FROM tabA JOIN tabB ON tabA.name = tabB.name; --表示返回都含有的name值对应的字段 外连接OUTER JOIN1、LEFT JOIN：显示左表全部和左右符合连接条件的记录2、RIGHT JOIN：显示左右符合连接条件的记录和右表全部记录3、若某字段只存在某一表，则另一表的里字段返回null 多表连接SELECT goods_id,goods_name,cate_name,brand_name,goods_price FROM tdb_goods AS g INNER JOIN tdb_goods_cates AS c ON g.cate_id = c.cate_id INNER JOIN tdb_goods_brands AS b ON g.brand_id = b.brand_id\G; 注意：INNER和INNER之间是没有逗号的 关于外连接的几点说明外连接：以左外连接为例：A LEFT JOIN B join_condition数据表B的结果集依赖于数据表A数据表A的结果集根据左连接条件依赖所有数据表(B表除外)左外连接条件决定如何检索数据表B(在没有指定WHERE条件的情况下)如果数据表A的某条记录符合WHERE条件，但是在数据表B不存在符合连接条件的记录，将生成一个所有列为空的额外的B行内连接：使用内连接查找的记录在连接数据表中不存在，并且在WHERE子句中尝试一下操作：column_name IS NULL 。如果 column_name 被指定为 NOT NULL，MySQL将在找到符合连接着条件的记录后停止搜索更多的行（查找冲突） 无极限分类表设计无限分类：即在同一张表中既有父类，又有子类。通过在分类表中再增加多一个字段标识其属于哪一个父类的 ID 来实现。可以通过对同一张数据表的自身连接来进行查询，需要对表标识别名。 查找父级对应的名称： select s.type_id ,s.type_name,p.type_name As parent_name from tdb_goods_types s left join tdb_goods_types p on s.parent_id=p.type_id; 查找子级对应的名称： select p.type_id ,p.type_name,s.type_name from tdb_goods_types p left join tdb_goods_types s on p.type_id=s.parent_id; 查找有多少子级： select p.type_id ,p.type_name,COUNT(s.type_name) child_count from tdb_goods_types p left join tdb_goods_types s on p.type_id=s.parent_id GROUP BY p.type_name ORDER BY p.type_id; 多表删除（1）多表删除，将重复记录删除，保留ID号比较小的项（2）查找重复记录 SELECT goods_id,goods_name FROM tdb_goods GROUP BY goods_name HAVING count(goods_name) &gt;= 2; （3） 删除重复记录 DELETE t1 FROM tdb_goods AS t1 LEFT JOIN (SELECT goods_id,goods_name FROM tdb_goods GROUP BY goods_name HAVING count(goods_name) &gt;= 2 ) AS t2 ON t1.goods_name = t2.goods_name WHERE t1.goods_id &gt; t2.goods_id; 运算符和函数字符函数 函数名称 描述 CONCAT() 字符连接 CONCAT_WS() 使用指定的分隔符进行字符连接 FORMAT() 数字格式化 LOWER() 转换成小写字母 UPPER() 转换成大写字母 LEFT() 获取左侧字符 RIGHT() 获取右侧字符 数值运算符和函数比较运算符和函数日期时间函数信息函数聚合函数加密函数]]></content>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[输出csv]]></title>
    <url>%2F2017%2F07%2F09%2F%E8%BE%93%E5%87%BAcsv%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849function exportToCsv(filename, rows) &#123; var processRow = function (row) &#123; var finalVal = ''; for (var j = 0; j &lt; row.length; j++) &#123; var innerValue = row[j] === null ? '' : row[j].toString(); if (row[j] instanceof Date) &#123; innerValue = row[j].toLocaleString(); &#125;; var result = innerValue.replace(/"/g, '""'); if (result.search(/("|,|\n)/g) &gt;= 0) result = '"' + result + '"'; if (j &gt; 0) finalVal += ','; finalVal += result; &#125; return finalVal + '\n'; &#125;; var csvFile = ''; for (var i = 0; i &lt; rows.length; i++) &#123; csvFile += processRow(rows[i]); &#125; var blob = new Blob([csvFile], &#123; type: 'text/csv;charset=utf-8;' &#125;); if (navigator.msSaveBlob) &#123; // IE 10+ navigator.msSaveBlob(blob, filename); &#125; else &#123; var link = document.createElement("a"); if (link.download !== undefined) &#123; // feature detection // Browsers that support HTML5 download attribute var url = URL.createObjectURL(blob); link.setAttribute("href", url); link.setAttribute("download", filename); link.style.visibility = 'hidden'; document.body.appendChild(link); link.click(); document.body.removeChild(link); &#125; &#125; &#125; exportToCsv('export.csv', [ ['name','description'], ['david','123'], ['jona','""'], ['a','b'],])]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[install_ftp]]></title>
    <url>%2F2017%2F07%2F09%2Finstall-ftp%2F</url>
    <content type="text"><![CDATA[安装ftp服务安装12rpm -qa|grep vsftpyum install vsftpd -y 启动服务1service vsftpd start 添加ftp用户12adduser testpasswd test]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2016%2F11%2F25%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>